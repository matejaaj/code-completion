[
    {
        "id": 1,
        "prefix": "import sys\nimport time\nimport json\nimport random\nfrom abc import *\nfrom collections import deque\n\nclass GameState:\n    def __init__(self, data):\n        self.turn = int(data['turn'])\n        self.firstPlayerTurn = bool(data['firstPlayerTurn'])\n        self.player1 = Player(data['player1'])\n        self.player2 = Player(data['player2'])\n        self.board = [[str(cell) for cell in row] for row in data['board']]\n\nclass Player:\n    def __init__(self, data):\n        self.name = str(data['name'])\n        self.energy = int(data['energy'])\n        self.xp = int(data['xp'])\n        self.coins = int(data['coins'])\n        self.position = [int(pos) for pos in data['position']]\n        self.increased_backpack_duration = str(data['increased_backpack_duration'])\n        self.daze_turns = int(data['daze_turns'])\n        self.frozen_turns = int(data['frozen_turns'])\n        self.backpack_capacity = int(data['backpack_capacity'])\n        self.raw_minerals = int(data['raw_minerals'])\n        self.processed_minerals = int(data['processed_minerals'])\n        self.raw_diamonds = int(data['raw_diamonds'])\n        self.processed_diamonds = int(data['processed_diamonds'])\n    \n\n    def find_nearest_target(self, board, target_label):\n        min_distance = float('inf')\n        nearest_target_coords = None\n\n        for i in range(len(board)):\n            for j in range(len(board[i])):\n                cell = board[i][j]\n                if isinstance(cell, str) and cell.startswith(target_label):\n                    distance = ((self.position[0] - i) ** 2 + (self.position[1] - j) ** 2) ** 0.5\n                    if distance < min_distance:\n                        min_distance = distance\n                        nearest_target_coords = [i, j] \n\n        return nearest_target_coords\n\n    def find_best_ore(self, board, target_label, value_weight=0.5):\n        best_score = float('-inf')\n        best_ore_coords = None\n\n        for i in range(len(board)):\n            for j in range(len(board[i])):\n                cell = board[i][j]\n                if isinstance(cell, str) and cell.startswith(target_label):\n                    parts = cell.split('_')\n                    if len(parts) >= 3 and int(parts[1]) >= 2:\n                        number1 = int(parts[1])\n                        number2 = int(parts[2])\n\n                        distance = ((self.position[0] - i) ** 2 + (self.position[1] - j) ** 2) ** 0.5\n                        score = number1 + value_weight / (distance + 0.1) \n\n                        if score > best_score:\n                            best_score = score\n                            best_ore_coords = [i, j]\n\n        return best_ore_coords\n\n\n    def find_accessible_neighbor(self, board, target_coords, player_coordinates):\n        target_i, target_j = target_coords\n        player_i, player_j = player_coordinates\n        neighbors = [\n            (target_i - 1, target_j), (target_i + 1, target_j),\n            (target_i, target_j - 1), (target_i, target_j + 1)\n        ]\n\n        closest_neighbor = None\n        min_distance = float('inf')  # Initialize min_distance with infinity\n\n        for ni, nj in neighbors:\n            if 0 <= ni < len(board) and 0 <= nj < len(board[0]):  # Check bounds\n                if board[ni][nj] == 'E':  # Check if the neighbor is accessible\n                    # Calculate Euclidean distance from the neighbor to the player's position\n                    distance = ((ni - player_i) ** 2 + (nj - player_j) ** 2) ** 0.5\n                    if distance < min_distance:\n                        min_distance = distance\n                        closest_neighbor = [ni, nj]\n\n        return closest_neighbor\n\n    def BuildAction(self,x,y):\n        return f'build {x} {y}'\n\n    def RestAction():\n        return 'rest'\n\n    def ShopAction(self,action):\n        return f'shop {action}'\n\n    def AttackAction(self,x,y):\n        return f'attack {x} {y}'\n\n    def ConversionsAction(self,dCoins,mCoins,dEnergy,mEnergy,dXp,mXp):\n        return f\"conv {dCoins} diamond {mCoins} mineral to coins, {dEnergy} diamond {mEnergy} mineral to energy, {dXp} diamond {mXp} mineral to xp\"\n\n    def PutAction(self,X,Y,N,M):\n        return f'refinement-take {X} {Y} mineral {N} diamond {M}'\n\n    def TakeAction(self,X,Y,N,M):\n        return f'refinement-take {X} {Y} mineral {N} diamond {M}'\n\n    def ConversionXPSplit(self):\n        total_minerals = self.raw_minerals\n        total_diamonds = self.raw_diamonds \n\n        if self.energy <= 500:\n            if total_minerals > 2:\n                m_energy =  max(2, total_minerals - 2)\n                m_xp = total_minerals - m_energy \n            else:\n                m_energy = 0 \n                m_xp = total_minerals \n\n            if total_diamonds >= 5:\n                d_xp = max(total_diamonds, 5) \n                d_coins = 0\n            else:\n                d_coins = 0  \n                d_xp = total_diamonds  \n\n            m_coins = 0\n            d_energy = 0\n        else:\n            if total_minerals > 2:\n                m_xp =  max(2, total_minerals - 2)\n                m_energy = total_minerals - m_xp\n            else:\n                m_energy = 0 \n                m_xp = total_minerals \n            if total_diamonds >= 5:\n                d_xp = max(total_diamonds, 5) \n                d_coins = total_diamonds - d_xp \n            else:\n                d_coins = 0  \n                d_xp = total_diamonds    \n\n            m_coins = 0\n            d_energy = 0\n\n        return self.ConversionsAction(d_coins, m_coins, d_energy, m_energy, d_xp, m_xp)\n\n\n    def GetDestroyFactorySequence(self, gameState):\n        player_coordinates = self.GetPlayerCordinates(gameState)\n        target_coordinates = self.find_nearest_target(gameState.board, 'F')\n        if target_coordinates is None: return\n        move_coordinates = self.find_accessible_neighbor(gameState.board, target_coordinates, player_coordinates)\n        actions = self.get_move_sequence(gameState, player_coordinates, move_coordinates)\n\n        factory = gameState.board[target_coordinates[0]][target_coordinates[1]]\n        factory_parts = factory.split('_')\n        counter = int(factory_parts[2])\n        while(counter > 0 ):\n            actions.append(f\"attack {target_coordinates[0]} {target_coordinates[1]}\")\n            counter -= 1\n        return actions\n\n\n    def ConversionMoneySplit(self):\n        total_minerals = self.raw_minerals\n        total_diamonds = self.raw_diamonds \n\n        # Initialize variables with default values\n        d_coins = 0\n        d_xp = 0\n        m_energy = 0\n        m_xp = 0\n        m_coins = 0\n        d_energy = 0\n\n        if self.energy <= 500:\n            if total_minerals >= 2:\n                m_energy = max(2, total_minerals - 2)\n                m_xp = total_minerals - m_energy \n            else:\n                m_xp = total_minerals \n\n            if total_diamonds >= 5:\n                d_xp = total_diamonds\n        else:\n            if total_minerals >= 2:\n                m_xp = max(2, total_minerals - 2)\n                m_energy = total_minerals - m_xp\n            else:\n                m_xp = total_minerals \n\n            d_xp = total_diamonds\n            d_coins = 0\n\n        return self.ConversionsAction(d_coins, m_coins, d_energy, m_energy, d_xp, m_xp)\n\n\n        \n    def GetOreCapacity(self, board, coordinates):\n        ore = board[coordinates[0]][coordinates[1]]\n        parts = ore.split('_')\n        return int(parts[1])\n    \n    def GetOreValue(self, board, coordinates):\n        ore = board[coordinates[0]][coordinates[1]]\n        parts = ore.split('_')\n        return 2 if parts[0] == 'M' else 5\n    \n    def GetHomePosition(self, gameState):\n        return [9,0] if gameState.firstPlayerTurn else [0,9]\n\n    def GoHomeActions(self, gameState, player_coordinates, home_coordinates):\n\n        actions = self.get_move_sequence(gameState, player_coordinates, home_coordinates)\n        if actions is None: return [\"shop daze\"]\n        return actions\n\n    def GetPlayerCordinates(self, gameState):\n        return myPlayer(gameState).position\n\n    def GetMiningSequence(self, gameState, objectToMine):\n        player_coordinates = self.GetPlayerCordinates(gameState)\n        target_coordinates = self.find_best_ore(gameState.board, objectToMine)\n        move_coordinates = self.find_accessible_neighbor(gameState.board, target_coordinates, player_coordinates)\n        actions = self.get_move_sequence(gameState, player_coordinates,  move_coordinates)\n\n        player_coordinates = move_coordinates\n        player_capacity = int(myPlayer(gameState).backpack_capacity)  \n        ore_capacity = self.GetOreCapacity(gameState.board, target_coordinates)\n        ore_value = self.GetOreValue(gameState.board, target_coordinates)\n\n        while player_capacity <= 8 and ore_capacity > 0:\n            if player_capacity + ore_value > 8:\n                break\n            \n            actions.append(f\"mine {target_coordinates[0]} {target_coordinates[1]}\")\n            player_capacity += ore_value\n            ore_capacity -= 1 \n            \n            self.raw_minerals += 1\n\n        home_coordinates = self.GetHomePosition(gameState)\n\n        actions.extend(self.GoHomeActions(gameState, player_coordinates, home_coordinates))\n        actions.append(self.ConversionXPSplit())\n        self.raw_minerals = 0\n        return actions\n\n    def GetMiningMoneySequence(self, gameState, objectToMine):\n        player_coordinates = self.GetPlayerCordinates(gameState)\n        target_coordinates = self.find_best_ore(gameState.board, objectToMine)\n        move_coordinates = self.find_accessible_neighbor(gameState.board, target_coordinates, player_coordinates)\n        actions = self.get_move_sequence(gameState, player_coordinates,  move_coordinates)\n\n        player_coordinates = move_coordinates\n        player_capacity = int(myPlayer(gameState).backpack_capacity)  \n        ore_capacity = self.GetOreCapacity(gameState.board, target_coordinates)\n        ore_value = self.GetOreValue(gameState.board, target_coordinates)\n\n        while player_capacity <= 8 and ore_capacity > 0:\n            if player_capacity + ore_value > 8:\n                break\n            \n            actions.append(f\"mine {target_coordinates[0]} {target_coordinates[1]}\")\n            player_capacity += ore_value\n            ore_capacity -= 1 \n            \n            self.raw_minerals += 1\n\n        home_coordinates = self.GetHomePosition(gameState)\n\n        actions.extend(self.GoHomeActions(gameState, player_coordinates, home_coordinates))\n        actions.append(self.ConversionMoneySplit())\n        self.raw_minerals = 0\n        return actions\n    \n    def get_move_sequence(self, gameState,  from_coordinates, target_coordinates):\n        search = BreadthFirstSearch(gameState)\n        initial_state = RobotState(gameState, None, from_coordinates, target_coordinates)\n\n        path, _, _ = search.search(lambda: initial_state)\n\n        if path is None:\n            return []\n\n        path.pop(0)\n        return self.create_move_command(path)\n\n    def create_move_command(self, actions):\n        commands = []\n        for action in actions:  \n            commands.append(f\"move {action[0]} {action[1]}\")\n\n        return commands\n\nclass Search(object):\n\n    def __init__(self, gameState):\n        self.board = gameState.board\n        if gameState.firstPlayerTurn:\n            self.player = gameState.player1\n        else:\n            self.player = gameState.player2\n\n    def search(self, initial_state):\n\n        initial_state = initial_state()  \n        states_list = deque([initial_state]) \n        states_set = {initial_state.unique_hash()}  \n\n        processed_list = deque([])  \n        processed_set = set() \n\n        while len(states_list) > 0: \n            curr_state = self.select_state(states_list)  \n            states_set.remove(curr_state.unique_hash())  \n\n            processed_list.append(curr_state) \n            processed_set.add(curr_state.unique_hash())  \n\n            if curr_state.is_final_state():  \n                return Search.reconstruct_path(curr_state), processed_list, states_list\n\n            new_states = curr_state.get_next_states()\n            new_states = [new_state for new_state in new_states if\n                          new_state.unique_hash() not in processed_set and\n                          new_state.unique_hash() not in states_set]\n\n            states_list.extend(new_states)\n\n            states_set.update([new_state.unique_hash() for new_state in new_states])\n        return None, processed_list, states_list\n\n    @staticmethod\n    def reconstruct_path(final_state):\n        path = []\n        while final_state is not None:\n            path.append(final_state.position)\n            final_state = final_state.parent\n        return list(reversed(path))\n\n    @abstractmethod\n    def select_state(self, states):\n        pass\n\nclass BreadthFirstSearch(Search):\n    def select_state(self, states):\n        return states.popleft()     \nclass State(object):\n\n    @abstractmethod\n    def __init__(self, gameState, parent=None, position=None, goal_position=None):\n\n        self.bo",
        "middle": "ard = gameState.board ",
        "suffix": "        self.parent = parent \n        self.gameState = gameState\n\n        if self.parent is None:\n            if gameState.firstPlayerTurn:\n                  self.position = position\n                  self.player_code = \"1\"\n                  self.player = gameState.player2\n            else:\n                self.position = position\n                self.player_code = \"2\"\n                self.player = gameState.player2\n            self.goal_position = goal_position  \n        else: \n            self.position = position\n            self.goal_position = goal_position\n            self.player = self.parent.player\n            self.player_code = self.parent.player_code\n\n        self.depth = parent.depth + 1 if parent is not None else 1  \n\n    def get_next_states(self):\n        new_positions = self.get_legal_positions()\n        next_states = []\n        for new_position in new_positions:\n            next_state = self.__class__(self.gameState, self, new_position, self.goal_position)\n            next_states.append(next_state)\n        return next_states\n\n    def get_agent_code(self):\n        return self.player_code\n\n    @abstractmethod\n    def get_legal_positions(self):\n        \"\"\"\n        Apstraktna metoda koja treba da vrati moguce (legalne) sledece pozicije na osnovu trenutne pozicije.\n        :return: list\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def is_final_state(self):\n        \"\"\"\n        Apstraktna metoda koja treba da vrati da li je treuntno stanje zapravo zavrsno stanje.\n        :return: bool\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def unique_hash(self):\n        \"\"\"\n        Apstraktna metoda koja treba da vrati string koji je JEDINSTVEN za ovo stanje\n        (u odnosu na ostala stanja).\n        :return: str\n        \"\"\"\n        pass\n    \n    \n    @abstractmethod\n    def get_current_cost(self):\n        \"\"\"\n        Apstraktna metoda koja treba da vrati stvarnu dosadašnju trenutnu cenu za ovo stanje, odnosno g(n)\n        Koristi se za vodjene pretrage.\n        :return: float\n        \"\"\"\n        pass\nclass RobotState(State):\n\n    def __init__(self, gameState, parent=None, position=None, goal_position=None):\n        super().__init__(gameState, parent, position, goal_position)\n        if parent is None:\n            self.cost = 0\n        else: \n            self.cost = self.parent.cost + 1\n\n    def get_legal_positions(self):\n        retVal = []\n        \n        x = int(self.position[0])\n        y = int(self.position[1])\n        \n        if self.get_agent_code == \"1\":\n            base = \"A\"\n        else:\n            base = \"B\"\n\n        available_fileds = [base, \"E\", self.get_agent_code]\n        if y < 9:\n            for i in range(y + 1, 10):\n                if self.board[x][i] not in available_fileds:\n                    break\n                else:\n                    retVal.append([x, i])\n\n        if y > 0:\n            for i in range(y - 1, -1, -1):\n                if self.board[x][i] not in available_fileds:\n                    break\n                else:\n                    retVal.append([x, i])\n\n        if x < 9:\n            for i in range(x + 1, 10):\n                if self.board[i][y] not in available_fileds:\n                    break\n                else:\n                    retVal.append([i, y])\n\n        if x > 0:\n            for i in range(x - 1, -1, -1):\n                if self.board[i][y] not in available_fileds:\n                    break\n                else:\n                    retVal.append([i, y])\n\n        return retVal\n\n    def is_final_state(self):\n        return self.position == self.goal_position\n\n    def unique_hash(self):\n        return f\"{self.position}{self.player.energy}{self.player.raw_minerals}\"\n\n    def manhattan_distance(self, pointA, pointB):\n        return abs(pointA[0] - pointB[0]) + abs(pointA[1] - pointB[1])\n\n    \n    def get_current_cost(self):\n        return self.cost\n\ndef count_letters_in_matrix(matrix):\n    count_D = 0\n    count_M = 0\n    \n    # Iterate through each row in the matrix\n    for row in matrix:\n        # Iterate through each element in the row\n        for element in row:\n            # Count the occurrences of 'D' and 'M' in the element\n            count_D += element.count('D')\n            count_M += element.count('M')\n\n    return [count_D, count_M]\n\n\n\ndef ValidateDaze(gameState):\n    player = myPlayer(gameState)\n    if(player.coins >= 10 ): \n        return True\n    else:\n        return False\n\ndef is_enemy_nearby(x, y, enemy_position, board_size=10):\n    neighbor_offsets = [\n        (-1, -1), (-1, 0), (-1, 1),\n        (0, -1),         (0, 1),\n        (1, -1), (1, 0), (1, 1)\n    ]\n\n    for dx, dy in neighbor_offsets:\n        neighbor_x = x + dx\n        neighbor_y = y + dy\n        if 0 <= neighbor_x < board_size and 0 <= neighbor_y < board_size:\n            if (neighbor_x, neighbor_y) == enemy_position:\n                return True\n\n    return False\n\nmove_sequence = []\n\ncnt_money = 0\ncnt_xp = 0\ndaze_cnt = 0\ntest_bot_cnt = 0\n\ndef myPlayer(gameState):\n    if gameState.firstPlayerTurn:\n        return gameState.player1\n    else:\n        return gameState.player2\n\ndef enemyPlayer(gameState):\n    if gameState.firstPlayerTurn:\n        return gameState.player2\n    else:\n        return gameState.player1\n\n\nwhile True:\n    line = sys.stdin.readline().strip()\n    json_data = json.loads(line)\n\n    gameState = GameState(json_data)\n\n    player = myPlayer(gameState)\n    enemy = enemyPlayer(gameState)\n\n    if enemy.name == \"Topic Team\":\n        position = enemy.position\n        if(gameState.turn >= 200):\n            if (enemy.position == [0,9] or enemy.position ==[9,0]) and player.xp >= 200:\n                if enemy.daze_turns <= 1:\n                    if(ValidateDaze(gameState)):\n                        move_sequence.insert(0, \"shop daze\")\n        if not move_sequence :\n            move_sequence = player.GetDestroyFactorySequence(gameState)\n\n    ores = count_letters_in_matrix(gameState.board)\n    \n    if not move_sequence and (enemy.processed_diamonds != 0 or enemy.processed_minerals != 0):\n        move_sequence = player.GetDestroyFactorySequence(gameState)\n    elif ores[0] > ores[1] * 2:\n        if not move_sequence:\n            if cnt_money % 3 < 2:\n                move_sequence = player.GetMiningMoneySequence(gameState, 'D')\n                cnt_money += 1\n            else:\n                move_sequence = player.GetMiningMoneySequence(gameState, 'M')\n                cnt_money += 1\n\n    elif ores[1] > 8:\n        if not move_sequence:\n            if cnt_xp % 5 < 4:\n                move_sequence = player.GetMiningSequence(gameState, 'M')\n                cnt_money += 1\n    else: \n        if not move_sequence:\n            move_sequence = player.GetMiningSequence(gameState, 'M')\n\n    if(enemy.name != \"Topic Team\"):\n        if (enemy.position == [0,9] or enemy.position ==[9,0]) and player.xp >= 20 and daze_cnt == 0:\n                if enemy.daze_turns <= 1:\n                    if(ValidateDaze(gameState)):\n                        move_sequence.insert(0, \"shop daze\")\n                    if(ValidateDaze(gameState)):\n                        move_sequence.insert(0, \"shop daze\")\n                        daze_cnt += 1000\n\n    temp = move_sequence.pop(0)\n    if temp.startswith('move') and player.daze_turns != 0:\n        parts= temp.split(' ')\n        targetX= int(parts[1])\n        targetY= int(parts[2])\n        dX= targetX - int(player.position[0])\n        dY= targetY - int(player.position[1])\n        newX= int(player.position[0]) - dX\n        newY= int(player.position[1]) - dY\n        temp=f'move {newX} {newY}'\n\n\n    if temp.startswith('move'):\n        px, py = player.position\n        parts= temp.split(' ')\n        tx = int(parts[1])\n        ty = int(parts[2])\n        ex, ey = enemy.position\n\n        if ((tx - px) * (ey - py) - (ty - py) * (ex - px) == 0 and min(px, tx) <= ex <= max(px, tx) and min(py, ty) <= ey <= max(py, ty)):\n            move_sequence.insert(0, f\"move {tx} {ty}\")\n            #move_sequence.insert(0, \"rest\")\n            #temp = move_sequence.pop(0)\n            print(\"rest\", flush=True)\n            continue\n\n    if(temp.startswith('attack')):\n        attack_parts = temp.split(\" \")\n        x = int(attack_parts[1])\n        y = int(attack_parts[2])\n\n        if is_enemy_nearby(x, y, enemy.position):\n            move_sequence = myPlayer.GetMiningSequence(gameState, 'M')\n            print(\"rest\", flush = True)\n\n    parts = temp.split() \n\n    if len(parts) >= 3: \n        command = parts[0]\n        if(command == \"mine\"):\n            x = int(parts[1])  \n            y = int(parts[2])  \n\n            ore = gameState.board[x][y]\n            prts = ore.split('_')\n            remaining = int(prts[1])\n            if remaining == 0: #invalid komanda za mine\n                move_sequence.clear()\n                move_sequence = player.GetMiningSequence(gameState, \"M\")\n                temp = move_sequence.pop(0)     \n\n    print(temp, flush=True)\n",
        "prediction": "",
        "file": "aibg_hackaton.py"
    },
    {
        "id": 2,
        "prefix": "import sys\nimport time\nimport json\nimport random\nfrom abc import *\nfrom collections import deque\n\nclass GameState:\n    def __init__(self, data):\n        self.turn = int(data['turn'])\n        self.firstPlayerTurn = bool(data['firstPlayerTurn'])\n        self.player1 = Player(data['player1'])\n        self.player2 = Player(data['player2'])\n        self.board = [[str(cell) for cell in row] for row in data['board']]\n\nclass Player:\n    def __init__(self, data):\n        self.name = str(data['name'])\n        self.energy = int(data['energy'])\n        self.xp = int(data['xp'])\n        self.coins = int(data['coins'])\n        self.position = [int(pos) for pos in data['position']]\n        self.increased_backpack_duration = str(data['increased_backpack_duration'])\n        self.daze_turns = int(data['daze_turns'])\n        self.frozen_turns = int(data['frozen_turns'])\n        self.backpack_capacity = int(data['backpack_capacity'])\n        self.raw_minerals = int(data['raw_minerals'])\n        self.processed_minerals = int(data['processed_minerals'])\n        self.raw_diamonds = int(data['raw_diamonds'])\n        self.processed_diamonds = int(data['processed_diamonds'])\n    \n\n    def find_nearest_target(self, board, target_label):\n        min_distance = float('inf')\n        nearest_target_coords = None\n\n        for i in range(len(board)):\n            for j in range(len(board[i])):\n                cell = board[i][j]\n                if isinstance(cell, str) and cell.startswith(target_label):\n                    distance = ((self.position[0] - i) ** 2 + (self.position[1] - j) ** 2) ** 0.5\n                    if distance < min_distance:\n                        min_distance = distance\n                        nearest_target_coords = [i, j] \n\n        return nearest_target_coords\n\n    def find_best_ore(self, board, target_label, value_weight=0.5):\n        best_score = float('-inf')\n        best_ore_coords = None\n\n        for i in range(len(board)):\n            for j in range(len(board[i])):\n                cell = board[i][j]\n                if isinstance(cell, str) and cell.startswith(target_label):\n                    parts = cell.split('_')\n                    if len(parts) >= 3 and int(parts[1]) >= 2:\n                        number1 = int(parts[1])\n                        number2 = int(parts[2])\n\n                        distance = ((self.position[0] - i) ** 2 + (self.position[1] - j) ** 2) ** 0.5\n                        score = number1 + value_weight / (distance + 0.1) \n\n                        if score > best_score:\n                            best_score = score\n                            best_ore_coords = [i, j]\n\n        return best_ore_coords\n\n\n    def find_accessible_neighbor(self, board, target_coords, player_coordinates):\n        target_i, target_j = target_coords\n        player_i, player_j = player_coordinates\n        neighbors = [\n            (target_i - 1, target_j), (target_i + 1, target_j),\n            (target_i, target_j - 1), (target_i, target_j + 1)\n        ]\n\n        closest_neighbor = None\n        min_distance = float('inf')  # Initialize min_distance with infinity\n\n        for ni, nj in neighbors:\n            if 0 <= ni < len(board) and 0 <= nj < len(board[0]):  # Check bounds\n                if board[ni][nj] == 'E':  # Check if the neighbor is accessible\n                    # Calculate Euclidean distance from the neighbor to the player's position\n                    distance = ((ni - player_i) ** 2 + (nj - player_j) ** 2) ** 0.5\n                    if distance < min_distance:\n                        min_distance = distance\n                        closest_neighbor = [ni, nj]\n\n        return closest_neighbor\n\n    def BuildAction(self,x,y):\n        return f'build {x} {y}'\n\n    def RestAction():\n        return 'rest'\n\n    def ShopAction(self,action):\n        return f'shop {action}'\n\n    def AttackAction(self,x,y):\n        return f'attack {x} {y}'\n\n    def ConversionsAction(self,dCoins,mCoins,dEnergy,mEnergy,dXp,mXp):\n        return f\"conv {dCoins} diamond {mCoins} mineral to coins, {dEnergy} diamond {mEnergy} mineral to energy, {dXp} diamond {mXp} mineral to xp\"\n\n    def PutAction(self,X,Y,N,M):\n        return f'refinement-take {X} {Y} mineral {N} diamond {M}'\n\n    def TakeAction(self,X,Y,N,M):\n        return f'refinement-take {X} {Y} mineral {N} diamond {M}'\n\n    def ConversionXPSplit(self):\n        total_minerals = self.raw_minerals\n        total_diamonds = self.raw_diamonds \n\n        if self.energy <= 500:\n            if total_minerals > 2:\n                m_energy =  max(2, total_minerals - 2)\n                m_xp = total_minerals - m_energy \n            else:\n                m_energy = 0 \n                m_xp = total_minerals \n\n            if total_diamonds >= 5:\n                d_xp = max(total_diamonds, 5) \n                d_coins = 0\n            else:\n                d_coins = 0  \n                d_xp = total_diamonds  \n\n            m_coins = 0\n            d_energy = 0\n        else:\n            if total_minerals > 2:\n                m_xp =  max(2, total_minerals - 2)\n                m_energy = total_minerals - m_xp\n            else:\n                m_energy = 0 \n                m_xp = total_minerals \n            if total_diamonds >= 5:\n                d_xp = max(total_diamonds, 5) \n                d_coins = total_diamonds - d_xp \n            else:\n                d_coins = 0  \n                d_xp = total_diamonds    \n\n            m_coins = 0\n            d_energy = 0\n\n        return self.ConversionsAction(d_coins, m_coins, d_energy, m_energy, d_xp, m_xp)\n\n\n    def GetDestroyFactorySequence(self, gameState):\n        player_coordinates = self.GetPlayerCordinates(gameState)\n        target_coordinates = self.find_nearest_target(gameState.board, 'F')\n        if target_coordinates is None: return\n        move_coordinates = self.find_accessible_neighbor(gameState.board, target_coordinates, player_coordinates)\n        actions = self.get_move_sequence(gameState, player_coordinates, move_coordinates)\n\n        factory = gameState.board[target_coordinates[0]][target_coordinates[1]]\n        factory_parts = factory.split('_')\n        counter = int(factory_parts[2])\n        while(counter > 0 ):\n            actions.append(f\"attack {target_coordinates[0]} {target_coordinates[1]}\")\n            counter -= 1\n        return actions\n\n\n    def ConversionMoneySplit(self):\n        total_minerals = self.raw_minerals\n        total_diamonds = self.raw_diamonds \n\n        # Initialize variables with default values\n        d_coins = 0\n        d_xp = 0\n        m_energy = 0\n        m_xp = 0\n        m_coins = 0\n        d_energy = 0\n\n        if self.energy <= 500:\n            if total_minerals >= 2:\n                m_energy = max(2, total_minerals - 2)\n                m_xp = total_minerals - m_energy \n            else:\n                m_xp = total_minerals \n\n            if total_diamonds >= 5:\n                d_xp = total_diamonds\n        else:\n            if total_minerals >= 2:\n                m_xp = max(2, total_minerals - 2)\n                m_energy = total_minerals - m_xp\n            else:\n                m_xp = total_minerals \n\n            d_xp = total_diamonds\n            d_coins = 0\n\n        return self.ConversionsAction(d_coins, m_coins, d_energy, m_energy, d_xp, m_xp)\n\n\n        \n    def GetOreCapacity(self, board, coordinates):\n        ore = board[coordinates[0]][coordinates[1]]\n        parts = ore.split('_')\n        return int(parts[1])\n    \n    def GetOreValue(self, board, coordinates):\n        ore = board[coordinates[0]][coordinates[1]]\n        parts = ore.split('_')\n        return 2 if parts[0] == 'M' else 5\n    \n    def GetHomePosition(self, gameState):\n        return [9,0] if gameState.firstPlayerTurn else [0,9]\n\n    def GoHomeActions(self, gameState, player_coordinates, home_coordinates):\n\n        actions = self.get_move_sequence(gameState, player_coordinates, home_coordinates)\n        if actions is None: return [\"shop daze\"]\n        return actions\n\n    def GetPlayerCordinates(self, gameState):\n        return myPlayer(gameState).position\n\n    def GetMiningSequence(self, gameState, objectToMine):\n        player_coordinates = self.GetPlayerCordinates(gameState)\n        target_coordinates = self.find_best_ore(gameState.board, objectToMine)\n        move_coordinates = self.find_accessible_neighbor(gameState.board, target_coordinates, player_coordinates)\n        actions = self.get_move_sequence(gameState, player_coordinates,  move_coordinates)\n\n        player_coordinates = move_coordinates\n        player_capacity = int(myPlayer(gameState).backpack_capacity)  \n        ore_capacity = self.GetOreCapacity(gameState.board, target_coordinates)\n        ore_value = self.GetOreValue(gameState.board, target_coordinates)\n\n        while player_capacity <= 8 and ore_capacity > 0:\n            if player_capacity + ore_value > 8:\n                break\n            \n            actions.append(f\"mine {target_coordinates[0]} {target_coordinates[1]}\")\n            player_capacity += ore_value\n            ore_capacity -= 1 \n            \n            self.raw_minerals += 1\n\n        home_coordinates = self.GetHomePosition(gameState)\n\n        actions.extend(self.GoHomeActions(gameState, player_coordinates, home_coordinates))\n        actions.append(self.ConversionXPSplit())\n        self.raw_minerals = 0\n        return actions\n\n    def GetMiningMoneySequence(self, gameState, objectToMine):\n        player_coordinates = self.GetPlayerCordinates(gameState)\n        target_coordinates = self.find_best_ore(gameState.board, objectToMine)\n        move_coordinates = self.find_accessible_neighbor(gameState.board, target_coordinates, player_coordinates)\n        actions = self.get_move_sequence(gameState, player_coordinates,  move_coordinates)\n\n        player_coordinates = move_coordinates\n        player_capacity = int(myPlayer(gameState).backpack_capacity)  \n        ore_capacity = self.GetOreCapacity(gameState.board, target_coordinates)\n        ore_value = self.GetOreValue(gameState.board, target_coordinates)\n\n        while player_capacity <= 8 and ore_capacity > 0:\n            if player_capacity + ore_value > 8:\n                break\n            \n            actions.append(f\"mine {target_coordinates[0]} {target_coordinates[1]}\")\n            player_capacity += ore_value\n            ore_capacity -= 1 \n            \n            self.raw_minerals += 1\n\n        home_coordinates = self.GetHomePosition(gameState)\n\n        actions.extend(self.GoHomeActions(gameState, player_coordinates, home_coordinates))\n        actions.append(self.ConversionMoneySplit())\n        self.raw_minerals = 0\n        return actions\n    \n    def get_move_sequence(self, gameState,  from_coordinates, target_coordinates):\n        search = BreadthFirstSearch(gameState)\n        initial_state = RobotState(gameState, None, from_coordinates, target_coordinates)\n\n        path, _, _ = search.search(lambda: initial_state)\n\n        if path is None:\n            return []\n\n        path.pop(0)\n        return self.create_move_command(path)\n\n    def create_move_command(self, actions):\n        commands = []\n        for action in actions:  \n            commands.append(f\"move {action[0]} {action[1]}\")\n\n        return commands\n\nclass Search(object):\n\n    def __init__(self, gameState):\n        self.board = gameState.board\n        if gameState.firstPlayerTurn:\n            self.player = gameState.player1\n        else:\n            self.player = gameState.player2\n\n    def search(self, initial_state):\n\n        initial_state = initial_state()  \n        states_list = deque([initial_state]) \n        states_set = {initial_state.unique_hash()}  \n\n        processed_list = deque([])  \n        processed_set = set() \n\n        while len(states_list) > 0: \n            curr_state = self.select_state(states_list)  \n            states_set.remove(curr_state.unique_hash())  \n\n            processed_list.append(curr_state) \n            processed_set.add(curr_state.unique_hash())  \n\n            if curr_state.is_final_state():  \n                return Search.reconstruct_path(curr_state), processed_list, states_list\n\n            new_states = curr_state.get_next_states()\n            new_states = [new_state for new_state in new_states if\n                          new_state.unique_hash() not in processed_set and\n                          new_state.unique_hash() not in states_set]\n\n            states_list.extend(new_states)\n\n            states_set.update([new_state.unique_hash() for new_state in new_s",
        "middle": "tates])",
        "suffix": "        return None, processed_list, states_list\n\n    @staticmethod\n    def reconstruct_path(final_state):\n        path = []\n        while final_state is not None:\n            path.append(final_state.position)\n            final_state = final_state.parent\n        return list(reversed(path))\n\n    @abstractmethod\n    def select_state(self, states):\n        pass\n\nclass BreadthFirstSearch(Search):\n    def select_state(self, states):\n        return states.popleft()     \nclass State(object):\n\n    @abstractmethod\n    def __init__(self, gameState, parent=None, position=None, goal_position=None):\n\n        self.board = gameState.board \n        self.parent = parent \n        self.gameState = gameState\n\n        if self.parent is None:\n            if gameState.firstPlayerTurn:\n                  self.position = position\n                  self.player_code = \"1\"\n                  self.player = gameState.player2\n            else:\n                self.position = position\n                self.player_code = \"2\"\n                self.player = gameState.player2\n            self.goal_position = goal_position  \n        else: \n            self.position = position\n            self.goal_position = goal_position\n            self.player = self.parent.player\n            self.player_code = self.parent.player_code\n\n        self.depth = parent.depth + 1 if parent is not None else 1  \n\n    def get_next_states(self):\n        new_positions = self.get_legal_positions()\n        next_states = []\n        for new_position in new_positions:\n            next_state = self.__class__(self.gameState, self, new_position, self.goal_position)\n            next_states.append(next_state)\n        return next_states\n\n    def get_agent_code(self):\n        return self.player_code\n\n    @abstractmethod\n    def get_legal_positions(self):\n        \"\"\"\n        Apstraktna metoda koja treba da vrati moguce (legalne) sledece pozicije na osnovu trenutne pozicije.\n        :return: list\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def is_final_state(self):\n        \"\"\"\n        Apstraktna metoda koja treba da vrati da li je treuntno stanje zapravo zavrsno stanje.\n        :return: bool\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def unique_hash(self):\n        \"\"\"\n        Apstraktna metoda koja treba da vrati string koji je JEDINSTVEN za ovo stanje\n        (u odnosu na ostala stanja).\n        :return: str\n        \"\"\"\n        pass\n    \n    \n    @abstractmethod\n    def get_current_cost(self):\n        \"\"\"\n        Apstraktna metoda koja treba da vrati stvarnu dosadašnju trenutnu cenu za ovo stanje, odnosno g(n)\n        Koristi se za vodjene pretrage.\n        :return: float\n        \"\"\"\n        pass\nclass RobotState(State):\n\n    def __init__(self, gameState, parent=None, position=None, goal_position=None):\n        super().__init__(gameState, parent, position, goal_position)\n        if parent is None:\n            self.cost = 0\n        else: \n            self.cost = self.parent.cost + 1\n\n    def get_legal_positions(self):\n        retVal = []\n        \n        x = int(self.position[0])\n        y = int(self.position[1])\n        \n        if self.get_agent_code == \"1\":\n            base = \"A\"\n        else:\n            base = \"B\"\n\n        available_fileds = [base, \"E\", self.get_agent_code]\n        if y < 9:\n            for i in range(y + 1, 10):\n                if self.board[x][i] not in available_fileds:\n                    break\n                else:\n                    retVal.append([x, i])\n\n        if y > 0:\n            for i in range(y - 1, -1, -1):\n                if self.board[x][i] not in available_fileds:\n                    break\n                else:\n                    retVal.append([x, i])\n\n        if x < 9:\n            for i in range(x + 1, 10):\n                if self.board[i][y] not in available_fileds:\n                    break\n                else:\n                    retVal.append([i, y])\n\n        if x > 0:\n            for i in range(x - 1, -1, -1):\n                if self.board[i][y] not in available_fileds:\n                    break\n                else:\n                    retVal.append([i, y])\n\n        return retVal\n\n    def is_final_state(self):\n        return self.position == self.goal_position\n\n    def unique_hash(self):\n        return f\"{self.position}{self.player.energy}{self.player.raw_minerals}\"\n\n    def manhattan_distance(self, pointA, pointB):\n        return abs(pointA[0] - pointB[0]) + abs(pointA[1] - pointB[1])\n\n    \n    def get_current_cost(self):\n        return self.cost\n\ndef count_letters_in_matrix(matrix):\n    count_D = 0\n    count_M = 0\n    \n    # Iterate through each row in the matrix\n    for row in matrix:\n        # Iterate through each element in the row\n        for element in row:\n            # Count the occurrences of 'D' and 'M' in the element\n            count_D += element.count('D')\n            count_M += element.count('M')\n\n    return [count_D, count_M]\n\n\n\ndef ValidateDaze(gameState):\n    player = myPlayer(gameState)\n    if(player.coins >= 10 ): \n        return True\n    else:\n        return False\n\ndef is_enemy_nearby(x, y, enemy_position, board_size=10):\n    neighbor_offsets = [\n        (-1, -1), (-1, 0), (-1, 1),\n        (0, -1),         (0, 1),\n        (1, -1), (1, 0), (1, 1)\n    ]\n\n    for dx, dy in neighbor_offsets:\n        neighbor_x = x + dx\n        neighbor_y = y + dy\n        if 0 <= neighbor_x < board_size and 0 <= neighbor_y < board_size:\n            if (neighbor_x, neighbor_y) == enemy_position:\n                return True\n\n    return False\n\nmove_sequence = []\n\ncnt_money = 0\ncnt_xp = 0\ndaze_cnt = 0\ntest_bot_cnt = 0\n\ndef myPlayer(gameState):\n    if gameState.firstPlayerTurn:\n        return gameState.player1\n    else:\n        return gameState.player2\n\ndef enemyPlayer(gameState):\n    if gameState.firstPlayerTurn:\n        return gameState.player2\n    else:\n        return gameState.player1\n\n\nwhile True:\n    line = sys.stdin.readline().strip()\n    json_data = json.loads(line)\n\n    gameState = GameState(json_data)\n\n    player = myPlayer(gameState)\n    enemy = enemyPlayer(gameState)\n\n    if enemy.name == \"Topic Team\":\n        position = enemy.position\n        if(gameState.turn >= 200):\n            if (enemy.position == [0,9] or enemy.position ==[9,0]) and player.xp >= 200:\n                if enemy.daze_turns <= 1:\n                    if(ValidateDaze(gameState)):\n                        move_sequence.insert(0, \"shop daze\")\n        if not move_sequence :\n            move_sequence = player.GetDestroyFactorySequence(gameState)\n\n    ores = count_letters_in_matrix(gameState.board)\n    \n    if not move_sequence and (enemy.processed_diamonds != 0 or enemy.processed_minerals != 0):\n        move_sequence = player.GetDestroyFactorySequence(gameState)\n    elif ores[0] > ores[1] * 2:\n        if not move_sequence:\n            if cnt_money % 3 < 2:\n                move_sequence = player.GetMiningMoneySequence(gameState, 'D')\n                cnt_money += 1\n            else:\n                move_sequence = player.GetMiningMoneySequence(gameState, 'M')\n                cnt_money += 1\n\n    elif ores[1] > 8:\n        if not move_sequence:\n            if cnt_xp % 5 < 4:\n                move_sequence = player.GetMiningSequence(gameState, 'M')\n                cnt_money += 1\n    else: \n        if not move_sequence:\n            move_sequence = player.GetMiningSequence(gameState, 'M')\n\n    if(enemy.name != \"Topic Team\"):\n        if (enemy.position == [0,9] or enemy.position ==[9,0]) and player.xp >= 20 and daze_cnt == 0:\n                if enemy.daze_turns <= 1:\n                    if(ValidateDaze(gameState)):\n                        move_sequence.insert(0, \"shop daze\")\n                    if(ValidateDaze(gameState)):\n                        move_sequence.insert(0, \"shop daze\")\n                        daze_cnt += 1000\n\n    temp = move_sequence.pop(0)\n    if temp.startswith('move') and player.daze_turns != 0:\n        parts= temp.split(' ')\n        targetX= int(parts[1])\n        targetY= int(parts[2])\n        dX= targetX - int(player.position[0])\n        dY= targetY - int(player.position[1])\n        newX= int(player.position[0]) - dX\n        newY= int(player.position[1]) - dY\n        temp=f'move {newX} {newY}'\n\n\n    if temp.startswith('move'):\n        px, py = player.position\n        parts= temp.split(' ')\n        tx = int(parts[1])\n        ty = int(parts[2])\n        ex, ey = enemy.position\n\n        if ((tx - px) * (ey - py) - (ty - py) * (ex - px) == 0 and min(px, tx) <= ex <= max(px, tx) and min(py, ty) <= ey <= max(py, ty)):\n            move_sequence.insert(0, f\"move {tx} {ty}\")\n            #move_sequence.insert(0, \"rest\")\n            #temp = move_sequence.pop(0)\n            print(\"rest\", flush=True)\n            continue\n\n    if(temp.startswith('attack')):\n        attack_parts = temp.split(\" \")\n        x = int(attack_parts[1])\n        y = int(attack_parts[2])\n\n        if is_enemy_nearby(x, y, enemy.position):\n            move_sequence = myPlayer.GetMiningSequence(gameState, 'M')\n            print(\"rest\", flush = True)\n\n    parts = temp.split() \n\n    if len(parts) >= 3: \n        command = parts[0]\n        if(command == \"mine\"):\n            x = int(parts[1])  \n            y = int(parts[2])  \n\n            ore = gameState.board[x][y]\n            prts = ore.split('_')\n            remaining = int(prts[1])\n            if remaining == 0: #invalid komanda za mine\n                move_sequence.clear()\n                move_sequence = player.GetMiningSequence(gameState, \"M\")\n                temp = move_sequence.pop(0)     \n\n    print(temp, flush=True)\n",
        "prediction": "",
        "file": "aibg_hackaton.py"
    },
    {
        "id": 3,
        "prefix": "import sys\nimport time\nimport json\nimport random\nfrom abc import *\nfrom collections import deque\n\nclass GameState:\n    def __init__(self, data):\n        self.turn = int(data['turn'])\n        self.firstPlayerTurn = bool(data['firstPlayerTurn'])\n        self.player1 = Player(data['player1'])\n        self.player2 = Player(data['player2'])\n        self.board = [[str(cell) for cell in row] for row in data['board']]\n\nclass Player:\n    def __init__(self, data):\n        self.name = str(data['name'])\n        self.energy = int(data['energy'])\n        self.xp = int(data['xp'])\n        self.coins = int(data['coins'])\n        self.position = [int(pos) for pos in data['position']]\n        self.increased_backpack_duration = str(data['increased_backpack_duration'])\n        self.daze_turns = int(data['daze_turns'])\n        self.frozen_turns = int(data['frozen_turns'])\n        self.backpack_capacity = int(data['backpack_capacity'])\n        self.raw_minerals = int(data['raw_minerals'])\n        self.processed_minerals = int(data['processed_minerals'])\n        self.raw_diamonds = int(data['raw_diamonds'])\n        self.processed_diamonds = int(data['processed_diamonds'])\n    \n\n    def find_nearest_target(self, board, target_label):\n        min_distance = float('inf')\n        nearest_target_coords = None\n\n        for i in range(len(board)):\n            for j in range(len(board[i])):\n                cell = board[i][j]\n                if isinstance(cell, str) and cell.startswith(target_label):\n                    distance = ((self.position[0] - i) ** 2 + (self.position[1] - j) ** 2) ** 0.5\n                    if distance < min_distance:\n                        min_distance = distance\n                        nearest_target_coords = [i, j] \n\n        return nearest_target_coords\n\n    def find_best_ore(self, board, target_label, value_weight=0.5):\n        best_score = float('-inf')\n        best_ore_coords = None\n\n        for i in range(len(board)):\n            for j in range(len(board[i])):\n                cell = board[i][j]\n                if isinstance(cell, str) and cell.startswith(target_label):\n                    parts = cell.split('_')\n                    if len(parts) >= 3 and int(parts[1]) >= 2:\n                        number1 = int(parts[1])\n                        number2 = int(parts[2])\n\n                        distance = ((self.position[0] - i) ** 2 + (self.position[1] - j) ** 2) ** 0.5\n                        score = number1 + value_weight / (distance + 0.1) \n\n                        if score > best_score:\n                            best_score = score\n                            best_ore_coords = [i, j]\n\n        return best_ore_coords\n\n\n    def find_accessible_neighbor(self, board, target_coords, player_coordinates):\n        target_i, target_j = target_coords\n        player_i, player_j = player_coordinates\n        neighbors = [\n            (target_i - 1, target_j), (target_i + 1, target_j),\n            (target_i, target_j - 1), (target_i, target_j + 1)\n        ]\n\n        closest_neighbor = None\n        min_distance = float('inf')  # Initialize min_distance with infinity\n\n        for ni, nj in neighbors:\n            if 0 <= ni < len(board) and 0 <= nj < len(board[0]):  # Check bounds\n                if board[ni][nj] == 'E':  # Check if the neighbor is accessible\n                    # Calculate Euclidean distance from the neighbor to the player's position\n                    distance = ((ni - player_i) ** 2 + (nj - player_j) ** 2) ** 0.5\n                    if distance < min_distance:\n                        min_distance = distance\n                        closest_neighbor = [ni, nj]\n\n        return closest_neighbor\n\n    def BuildAction(self,x,y):\n        return f'build {x} {y}'\n\n    def RestAction():\n        return 'rest'\n\n    def ShopAction(self,action):\n        return f'shop {action}'\n\n    def AttackAction(self,x,y):\n        return f'attack {x} {y}'\n\n    def ConversionsAction(self,dCoins,mCoins,dEnergy,mEnergy,dXp,mXp):\n        return f\"conv {dCoins} diamond {mCoins} mineral to coins, {dEnergy} diamond {mEnergy} mineral to energy, {dXp} diamond {mXp} mineral to xp\"\n\n    def PutAction(self,X,Y,N,M):\n        return f'refinement-take {X} {Y} mineral {N} diamond {M}'\n\n    def TakeAction(self,X,Y,N,M):\n        return f'refinement-take {X} {Y} mineral {N} diamond {M}'\n\n    def ConversionXPSplit(self):\n        total_minerals = self.raw_minerals\n        total_diamonds = self.raw_diamonds \n\n        if self.energy <= 500:\n            if total_minerals > 2:\n                m_energy =  max(2, total_minerals - 2)\n                m_xp = total_minerals - m_energy \n            else:\n                m_energy = 0 \n                m_xp = total_minerals \n\n            if total_diamonds >= 5:\n                d_xp = max(total_diamonds, 5) \n                d_coins = 0\n            else:\n                d_coins = 0  \n                d_xp = total_diamonds  \n\n            m_coins = 0\n            d_energy = 0\n        else:\n            if total_minerals > 2:\n                m_xp =  max(2, total_minerals - 2)\n                m_energy = total_minerals - m_xp\n            else:\n                m_energy = 0 \n                m_xp = total_minerals \n            if total_diamonds >= 5:\n                d_xp = max(total_diamonds, 5) \n                d_coins = total_diamonds - d_xp \n            else:\n                d_coins = 0  \n                d_xp = total_diamonds    \n\n            m_coins = 0\n            d_energy = 0\n\n        return self.ConversionsAction(d_coins, m_coins, d_energy, m_energy, d_xp, m_xp)\n\n\n    def GetDestroyFactorySequence(self, gameState):\n        player_coordinates = self.GetPlayerCordinates(gameState)\n        target_coordinates = self.find_nearest_target(gameState.board, 'F')\n        if target_coordinates is None: return\n        move_coordinates = self.find_accessible_neighbor(gameState.board, target_coordinates, player_coordinates)\n        actions = self.get_move_sequence(gameState, player_coordinates, move_coordinates)\n\n        factory = gameState.board[target_coordinates[0]][target_coordinates[1]]\n        factory_parts = factory.split('_')\n        counter = int(factory_parts[2])\n        while(counter > 0 ):\n            actions.append(f\"attack {target_coordinates[0]} {target_coordinates[1]}\")\n            counter -= 1\n        return actions\n\n\n    def ConversionMoneySplit(self):\n        total_minerals = self.raw_minerals\n        total_diamonds = self.raw_diamonds \n\n        # Initialize variables with default values\n        d_coins = 0\n        d_xp = 0\n        m_energy = 0\n        m_xp = 0\n        m_coins = 0\n        d_energy = 0\n\n        if self.energy <= 500:\n            if total_minerals >= 2:\n                m_energy = max(2, total_minerals - 2)\n                m_xp = total_minerals - m_energy \n            else:\n                m_xp = total_minerals \n\n            if total_diamonds >= 5:\n                d_xp = total_diamonds\n        else:\n            if total_minerals >= 2:\n                m_xp = max(2, total_minerals - 2)\n                m_energy = total_minerals - m_xp\n            else:\n                m_xp = total_minerals \n\n            d_xp = total_diamonds\n            d_coins = 0\n\n        return self.ConversionsAction(d_coins, m_coins, d_energy, m_energy, d_xp, m_xp)\n\n\n        \n    def GetOreCapacity(self, board, coordinates):\n        ore = board[coordinates[0]][coordinates[1]]\n        parts = ore.split('_')\n        return int(parts[1])\n    \n    def GetOreValue(self, board, coordinates):\n        ore = board[coordinates[0]][coordinates[1]]\n        parts = ore.split('_')\n        return 2 if parts[0] == 'M' else 5\n    \n    def GetHomePosition(self, gameState):\n        return [9,0] if gameState.firstPlayerTurn else [0,9]\n\n    def GoHomeActions(self, gameState, player_coordinates, home_coordinates):\n\n        actions = self.get_move_sequence(gameState, player_coordinates, home_coordinates)\n        if actions is None: return [\"shop daze\"]\n        return actions\n\n    def GetPlayerCordinates(self, gameState):\n        return myPlayer(gameState).position\n\n    def GetMiningSequence(self, gameState, objectToMine):\n        player_coordinates = self.GetPlayerCordinates(gameState)\n        target_coordinates = self.find_best_ore(gameState.board, objectToMine)\n        move_coordinates = self.find_accessible_neighbor(gameState.board, target_coordinates, player_coordinates)\n        actions = self.get_move_sequence(gameState, player_coordinates,  move_coordinates)\n\n        player_coordinates = move_coordinates\n        player_capacity = int(myPlayer(gameState).backpack_capacity)  \n        ore_capacity = self.GetOreCapacity(gameState.board, target_coordinates)\n        ore_value = self.GetOreValue(gameState.board, target_coordinates)\n\n        while player_capacity <= 8 and ore_capacity > 0:\n            if player_capacity + ore_value > 8:\n                break\n            \n            actions.append(f\"mine {target_coordinates[0]} {target_coordinates[1]}\")\n            player_capacity += ore_value\n            ore_capacity -= 1 \n            \n            self.raw_minerals += 1\n\n        home_coordinates = self.GetHomePosition(gameState)\n\n        actions.extend(self.GoHomeActions(gameState, player_coordinates, home_coordinates))\n        actions.append(self.ConversionXPSplit())\n        self.raw_minerals = 0\n        return actions\n\n    def GetMiningMoneySequence(self, gameState, objectToMine):\n        player_coordinates = self.GetPlayerCordinates(gameState)\n        target_coordinates = self.find_best_ore(gameState.board, objectToMine)\n        move_coordinates = self.find_accessible_neighbor(gameState.board, target_coordinates, player_coordinates)\n        actions = self.get_move_sequence(gameState, player_coordinates,  move_coordinates)\n\n        player_coordinates = move_coordinates\n        player_capacity = int(myPlayer(gameState).backpack_capacity)  \n        ore_capacity = self.GetOreCapacity(gameState.board, target_coordinates)\n        ore_value = self.GetOreValue(gameState.board, target_coordinates)\n\n        while player_capacity <= 8 and ore_capacity > 0:\n            if player_capacity + ore_value > 8:\n                break\n            \n            actions.append(f\"mine {target_coordinates[0]} {target_coordinates[1]}\")\n            player_capacity += ore_value\n            ore_capacity -= 1 \n            \n            self.raw_minerals += 1\n\n        home_coordinates = self.GetHomePosition(gameState)\n\n        actions.extend(self.GoHomeActions(gameState, player_coordinates, home_coordinates))\n        actions.append(self.ConversionMoneySplit())\n        self.raw_minerals = 0\n        return actions\n    \n    def get_move_sequence(self, gameState,  from_coordinates, target_coordinates):\n        search = BreadthFirstSearch(gameState)\n        initial_state = RobotState(gameState, None, from_coordinates, target_coordinates)\n\n        path, _, _ = search.search(lambda: initial_state)\n\n        if path is None:\n            return []\n\n        path.pop(0)\n        return self.create_move_command(path)\n\n    def create_move_command(self, actions):\n        commands = []\n        for action in actions:  \n            commands.append(f\"move {action[0]} {action[1]}\")\n\n        return commands\n\nclass Search(object):\n\n    def __init__(self, gameState):\n        self.board = gameState.board\n        if gameState.firstPlayerTurn:\n            self.player = gameState.player1\n        else:\n            self.player = gameState.player2\n\n    def search(self, initial_state):\n\n        initial_state = initial_state()  \n        states_list = deque([initial_state]) \n        states_set = {initial_state.unique_hash()}  \n\n        processed_list = deque([])  \n        processed_set = set() \n\n        while len(states_list) > 0: \n            curr_state = self.select_state(states_list)  \n            states_set.remove(curr_state.unique_hash())  \n\n            processed_list.append(curr_state) \n            processed_set.add(curr_state.unique_hash())  \n\n            if curr_state.is_final_state():  \n                return Search.reconstruct_path(curr_state), processed_list, states_list\n\n            new_states = curr_state.get_next_states()\n            new_states = [new_state for new_state in new_states if\n                          new_state.unique_hash() not in processed_set and\n                          new_state.unique_hash() not in states_set]\n\n            states_list.extend(new_states)\n\n            states_set.update([new_state.unique_hash() for new_state in new_states])\n        return None, processed_list, states_list\n\n    @staticmethod\n    def reconstruct_path(final_state):\n        path = []\n        while final_state is not None:\n            path.append(final_state.position)\n            final_state = final_state.parent\n        return list(reversed(path))\n\n    @abstractmethod\n    def select_state(self, states):\n        pass\n\nclass BreadthFirstSearch(Search):\n    def select_state(self, states):\n        return states.popleft()     \nclass State(object):\n\n    @abstractmethod\n    def __init__(self, gameState, parent=None, position=None, goal_position=None):\n\n        self.board = gameState.board \n        self.parent = parent \n        self.gameState = gameState\n\n        if self.parent is None:\n            if gameState.firstPlayerTurn:\n                  self.position = position\n                  self.player_code = \"1\"\n                  self.player = gameState.player2\n            else:\n                self.position = position\n                self.player_code = \"2\"\n                self.player = gameState.player2\n            self.goal_position = goal_position  \n        else: \n            self.position = position\n            self.goal_position = goal_position\n            self.player = self.parent.player\n            self.player_code = self.parent.player_code\n\n        self.depth = parent.depth + 1 if parent is not None else 1  \n\n    def get_next_states(self):\n        new_positions = self.get_legal_positions()\n        next_states = []\n        for new_position in new_positions:\n            next_state = self.__class__(self.gameState, self, new_position, self.goal_position)\n            next_states.append(next_state)\n        return next_states\n\n    def get_agent_code(self):\n        return self.player_code\n\n    @abstractmethod\n    def get_legal_positions(self):\n        \"\"\"\n        Apstraktna metoda koja treba da vrati moguce (legalne) sledece pozicije na osnovu trenutne pozicije.\n        :return: list\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def is_final_state(self):\n        \"\"\"\n        Apstraktna metoda koja treba da vrati da li je treuntno stanje zapravo zavrsno stanje.\n        :return: bool\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def unique_hash(self):\n        \"\"\"\n        Apstraktna metoda koja treba da vrati string koji je JEDINSTVEN za ovo stanje\n        (u odnosu na ostala stanja).\n        :return: str\n        \"\"\"\n        pass\n    \n    \n    @abstractmethod\n    def get_current_cost(self):\n        \"\"\"\n        Apstraktna metoda koja treba da vrati stvarnu dosadašnju trenutnu cenu za ovo stanje, odnosno g(n)\n        Koristi se za vodjene pretrage.\n        :return: float\n        \"\"\"\n        pass\nclass RobotState(State):\n\n    def __init__(self, gameState, parent=None, position=None, goal_position=None):\n        super().__init__(gameState, parent, position, goal_position)\n        if parent is None:\n            self.cost = 0\n        else: \n            self.cost = self.parent.cost + 1\n\n    def get_legal_positions(self):\n        retVal = []\n        \n        x = int(self.position[0])\n        y = int(self.position[1])\n        \n        if self.get_agent_code == \"1\":\n            base = \"A\"\n        else:\n            base = \"B\"\n\n        available_fileds = [base, \"E\", self.get_agent_code]\n        if y < 9:\n            for i in range(y + 1, 10):\n                if self.board[x][i] not in available_fileds:\n                    break\n                else:\n                    retVal.append([x, i])\n\n        if y > 0:\n            for i in range(y - 1, -1, -1):\n                if self.board[x][i] not in available_fileds:\n                    break\n                else:\n                    retVal.append([x, i])\n\n        if x < 9:\n            for i in range(x + 1, 10):\n                if self.board[i][y] not in available_fileds:\n                    break\n                else:\n                    retVal.append([i, y])\n\n        if x > 0:\n            for i in range(x - 1, -1, -1):\n                if self.board[i][y] not in available_fileds:\n                    break\n                else:\n                    retVal.append([i, y])\n\n        return retVal\n\n    def is_final_state(self):\n        return self.position == self.goal_position\n\n    def unique_hash(self):\n        return f\"{self.position}{self.player.energy}{self.player.raw_minerals}\"\n\n    def manhattan_distance(self, pointA, pointB):\n        return abs(pointA[0] - pointB[0]) + abs(pointA[1] - pointB[1])\n\n    \n    def get_current_cost(self):\n        return self.cost\n\ndef count_letters_in_matrix(matrix):\n    count_D = 0\n    count_M = 0\n    \n    # Iterate through each row in the matrix\n    for row in matrix:\n        # Iterate through each element in the row\n        for element in row:\n            # Count the occurrences of 'D' and 'M' in the element\n            count_D += element.count('D')\n            count_M += element.count('M')\n\n    return [count_D, count_M]\n\n\n\ndef ValidateDaze(gameState):\n    player = myPlayer(gameState)\n    if(player.coins >= 10 ): \n        return True\n    else:\n        return False\n\ndef is_enemy_nearby(x, y, enemy_position, board_size=10):\n    neighbor_offsets = [\n        (-1, -1), (-1, 0), (-1, 1),\n        (0, -1),         (0, 1),\n        (1, -1), (1, 0), (1, 1)\n    ]\n\n    for dx, dy in neighbor_offsets:\n        neighbor_x = x + dx\n        neighbor_y = y + dy\n        if 0 <= neighbor_x < board_size and 0 <= neighbor_y < board_size:\n            if (neighbor_x, neighbor_y) == enemy_position:\n                return True\n\n    return False\n\nmove_sequence = []\n\ncnt_money = 0\ncnt_xp = 0\ndaze_cnt = 0\ntest_bot_cnt = 0\n\ndef myPlayer(gameState):\n    if gameState.firstPlayerTurn:\n        return gameState.player1\n    else:\n        return gameState.player2\n\ndef enemyPlayer(gameState):\n    if gameState.firstPlayerTurn:\n        return gameState.player2\n    else:\n        return gameState.player1\n\n\nwhile True:\n    line = sys.stdin.readline().strip()\n    json_data = json.loads(line)\n\n    gameState = GameState(json_data)\n\n    player = myPlayer(gameState)\n    enemy = enemyPlayer(gameState)\n\n    if enemy.name == \"Topic Team\":\n        position = enemy.position\n        if(gameState.turn >= 200):\n            if (enemy.position == [0,9] or enemy.position ==[9,0]) and player.xp >= 200:\n                if enemy.daze_turns <= 1:\n                    if(ValidateDaze(gameState)):\n                        move_sequence.insert(0, \"shop daze\")\n        if not move_sequence :\n            move_sequence = player.GetDestroyFactorySequence(gameState)\n\n    ores = count_letters_in_matrix(gameState.board)\n    \n    if not move_sequence and (enemy.processed_diamonds != 0 or enemy.processed_minerals != 0):\n        move_sequence = player.GetDestroyFactorySequence(gameState)\n    elif ores[0] > ores[1] * 2:\n        if not move_sequence:\n            if cnt_money % 3 < 2:\n                move_sequence = player.GetMiningMoneySequence(gameState, 'D')\n                cnt_money += 1\n            else:\n                move_sequence = player.GetMiningMoneySequence(gameState, 'M')\n                cnt_money += 1\n\n    elif ores[1] > 8:\n        if not move_sequence:\n            if cnt_xp % 5 < 4:\n                move_sequence = player.GetMiningSequence(gameState, 'M')\n                cnt_money += 1\n    else: \n        if not move_sequence:\n            move_sequence = player.GetMiningSequence(gameState, 'M')\n\n    if(enemy.name != \"Topic Team\"):\n        if (enemy.position == [0,9] or enemy.position ==[9,0]) and player.xp >= 20 and daze_cnt == 0:\n                if enemy.daze_turns <= 1:\n                    if(ValidateDaze(gameState)):\n                        move_sequence.insert(0, \"shop daze\")\n                    if(ValidateDaze(gameState)):\n                        move_sequence.insert(0, \"shop daze\")\n                        daze_cnt += 1000\n\n    temp = move_sequence.pop(0)\n    if temp.startswith('move') and player.daze_turns != 0:\n        parts= temp.split(' ')\n        targetX= int(parts[1])\n        targetY= int(parts[2])\n        dX= targetX - int(player.position[0])\n        dY= targetY - int(player.position[1])\n        newX= int(player.position[0",
        "middle": "]) - dX",
        "suffix": "        newY= int(player.position[1]) - dY\n        temp=f'move {newX} {newY}'\n\n\n    if temp.startswith('move'):\n        px, py = player.position\n        parts= temp.split(' ')\n        tx = int(parts[1])\n        ty = int(parts[2])\n        ex, ey = enemy.position\n\n        if ((tx - px) * (ey - py) - (ty - py) * (ex - px) == 0 and min(px, tx) <= ex <= max(px, tx) and min(py, ty) <= ey <= max(py, ty)):\n            move_sequence.insert(0, f\"move {tx} {ty}\")\n            #move_sequence.insert(0, \"rest\")\n            #temp = move_sequence.pop(0)\n            print(\"rest\", flush=True)\n            continue\n\n    if(temp.startswith('attack')):\n        attack_parts = temp.split(\" \")\n        x = int(attack_parts[1])\n        y = int(attack_parts[2])\n\n        if is_enemy_nearby(x, y, enemy.position):\n            move_sequence = myPlayer.GetMiningSequence(gameState, 'M')\n            print(\"rest\", flush = True)\n\n    parts = temp.split() \n\n    if len(parts) >= 3: \n        command = parts[0]\n        if(command == \"mine\"):\n            x = int(parts[1])  \n            y = int(parts[2])  \n\n            ore = gameState.board[x][y]\n            prts = ore.split('_')\n            remaining = int(prts[1])\n            if remaining == 0: #invalid komanda za mine\n                move_sequence.clear()\n                move_sequence = player.GetMiningSequence(gameState, \"M\")\n                temp = move_sequence.pop(0)     \n\n    print(temp, flush=True)\n",
        "prediction": "",
        "file": "aibg_hackaton.py"
    },
    {
        "id": 4,
        "prefix": "import sys\nimport time\nimport json\nimport random\nfrom abc import *\nfrom collections import deque\n\nclass GameState:\n    def __init__(self, data):\n        self.turn = int(data['turn'])\n        self.firstPlayerTurn = bool(data['firstPlayerTurn'])\n        self.player1 = Player(data['player1'])\n        self.player2 = Player(data['player2'])\n        self.board = [[str(cell) for cell in row] for row in data['board']]\n\nclass Player:\n    def __init__(self, data):\n        self.name = str(data['name'])\n        self.energy = int(data['energy'])\n        self.xp = int(data['xp'])\n        self.coins = int(data['coins'])\n        self.position = [int(pos) for pos in data['position']]\n        self.increased_backpack_duration = str(data['increased_backpack_duration'])\n        self.daze_turns = int(data['daze_turns'])\n        self.frozen_turns = int(data['frozen_turns'])\n        self.backpack_capacity = int(data['backpack_capacity'])\n        self.raw_minerals = int(data['raw_minerals'])\n        self.processed_minerals = int(data['processed_minerals'])\n        self.raw_diamonds = int(data['raw_diamonds'])\n        self.processed_diamonds = int(data['processed_diamonds'])\n    \n\n    def find_nearest_target(self, board, target_label):\n        min_distance = float('inf')\n        nearest_target_coords = None\n\n        for i in range(len(board)):\n            for j in range(len(board[i])):\n                cell = board[i][j]\n                if isinstance(cell, str) and cell.startswith(target_label):\n                    distance = ((self.position[0] - i) ** 2 + (self.position[1] - j) ** 2) ** 0.5\n                    if distance < min_distance:\n                        min_distance = distance\n                        nearest_target_coords = [i, j] \n\n        return nearest_target_coords\n\n    def find_best_ore(self, board, target_label, value_weight=0.5):\n        best_score = float('-inf')\n        best_ore_coords = None\n\n        for i in range(len(board)):\n            for j in range(len(board[i])):\n                cell = board[i][j]\n                if isinstance(cell, str) and cell.startswith(target_label):\n                    parts = cell.split('_')\n                    if len(parts) >= 3 and int(parts[1]) >= 2:\n                        number1 = int(parts[1])\n                        number2 = int(parts[2])\n\n                        distance = ((self.position[0] - i) ** 2 + (self.position[1] - j) ** 2) ** 0.5\n                        score = number1 + value_weight / (distance + 0.1) \n\n                        if score > best_score:\n                            best_score = score\n                            best_ore_coords = [i, j]\n\n        return best_ore_coords\n\n\n    def find_accessible_neighbor(self, board, target_coords, player_coordinates):\n        target_i, target_j = target_coords\n        player_i, player_j = player_coordinates\n        neighbors = [\n            (target_i - 1, target_j), (target_i + 1, target_j),\n            (target_i, target_j - 1), (target_i, target_j + 1)\n        ]\n\n        closest_neighbor = None\n        min_distance = float('inf')  # Initialize min_distance with infinity\n\n        for ni, nj in neighbors:\n            if 0 <= ni < len(board) and 0 <= nj < len(board[0]):  # Check bounds\n                if board[ni][nj] == 'E':  # Check if the neighbor is accessible\n                    # Calculate Euclidean distance from the neighbor to the player's position\n                    distance = ((ni - player_i) ** 2 + (nj - player_j) ** 2) ** 0.5\n                    if distance < min_distance:\n                        min_distance = distance\n                        closest_neighbor = [ni, nj]\n\n        return closest_neighbor\n\n    def BuildAction(self,x,y):\n        return f'build {x} {y}'\n\n    def RestAction():\n        return 'rest'\n\n    def ShopAction(self,action):\n        return f'shop {action}'\n\n    def AttackAction(self,x,y):\n        return f'attack {x} {y}'\n\n    def ConversionsAction(self,dCoins,mCoins,dEnergy,mEnergy,dXp,mXp):\n        return f\"conv {dCoins} diamond {mCoins} mineral to coins, {dEnergy} diamond {mEnergy} mineral to energy, {dXp} diamond {mXp} mineral to xp\"\n\n    def PutAction(self,X,Y,N,M):\n        return f'refinement-take {X} {Y} mineral {N} diamond {M}'\n\n    def TakeAction(self,X,Y,N,M):\n        return f'refinement-take {X} {Y} mineral {N} diamond {M}'\n\n    def ConversionXPSplit(self):\n        total_minerals = self.raw_minerals\n        total_diamonds = self.raw_diamonds \n\n        if self.energy <= 500:\n            if total_minerals > 2:\n                m_energy =  max(2, total_minerals - 2)\n                m_xp = total_minerals - m_energy \n            else:\n                m_energy = 0 \n                m_xp = total_minerals \n\n            if total_diamonds >= 5:\n                d_xp = max(total_diamonds, 5) \n                d_coins = 0\n            else:\n                d_coins = 0  \n                d_xp = total_diamonds  \n\n            m_coins = 0\n            d_energy = 0\n        else:\n            if total_minerals > 2:\n                m_xp =  max(2, total_minerals - 2)\n                m_energy = total_minerals - m_xp\n            else:\n                m_energy = 0 \n                m_xp = total_minerals \n            if total_diamonds >= 5:\n                d_xp = max(total_diamonds, 5) \n                d_coins = total_diamonds - d_xp \n            else:\n                d_coins = 0  \n                d_xp = total_diamonds    \n\n            m_coins = 0\n            d_energy = 0\n\n        return self.ConversionsAction(d_coins, m_coins, d_energy, m_energy, d_xp, m_xp)\n\n\n    def GetDestroyFactorySequence(self, gameState):\n        player_coordinates = self.GetPlayerCordinates(gameState)\n        target_coordinates = self.find_nearest_target(gameState.board, 'F')\n        if target_coordinates is None: return\n        move_coordinates = self.find_accessible_neighbor(gameState.board, target_coordinates, player_coordinates)\n        actions = self.get_move_sequence(gameState, player",
        "middle": "_coordinates, move_coordinates)",
        "suffix": "\n        factory = gameState.board[target_coordinates[0]][target_coordinates[1]]\n        factory_parts = factory.split('_')\n        counter = int(factory_parts[2])\n        while(counter > 0 ):\n            actions.append(f\"attack {target_coordinates[0]} {target_coordinates[1]}\")\n            counter -= 1\n        return actions\n\n\n    def ConversionMoneySplit(self):\n        total_minerals = self.raw_minerals\n        total_diamonds = self.raw_diamonds \n\n        # Initialize variables with default values\n        d_coins = 0\n        d_xp = 0\n        m_energy = 0\n        m_xp = 0\n        m_coins = 0\n        d_energy = 0\n\n        if self.energy <= 500:\n            if total_minerals >= 2:\n                m_energy = max(2, total_minerals - 2)\n                m_xp = total_minerals - m_energy \n            else:\n                m_xp = total_minerals \n\n            if total_diamonds >= 5:\n                d_xp = total_diamonds\n        else:\n            if total_minerals >= 2:\n                m_xp = max(2, total_minerals - 2)\n                m_energy = total_minerals - m_xp\n            else:\n                m_xp = total_minerals \n\n            d_xp = total_diamonds\n            d_coins = 0\n\n        return self.ConversionsAction(d_coins, m_coins, d_energy, m_energy, d_xp, m_xp)\n\n\n        \n    def GetOreCapacity(self, board, coordinates):\n        ore = board[coordinates[0]][coordinates[1]]\n        parts = ore.split('_')\n        return int(parts[1])\n    \n    def GetOreValue(self, board, coordinates):\n        ore = board[coordinates[0]][coordinates[1]]\n        parts = ore.split('_')\n        return 2 if parts[0] == 'M' else 5\n    \n    def GetHomePosition(self, gameState):\n        return [9,0] if gameState.firstPlayerTurn else [0,9]\n\n    def GoHomeActions(self, gameState, player_coordinates, home_coordinates):\n\n        actions = self.get_move_sequence(gameState, player_coordinates, home_coordinates)\n        if actions is None: return [\"shop daze\"]\n        return actions\n\n    def GetPlayerCordinates(self, gameState):\n        return myPlayer(gameState).position\n\n    def GetMiningSequence(self, gameState, objectToMine):\n        player_coordinates = self.GetPlayerCordinates(gameState)\n        target_coordinates = self.find_best_ore(gameState.board, objectToMine)\n        move_coordinates = self.find_accessible_neighbor(gameState.board, target_coordinates, player_coordinates)\n        actions = self.get_move_sequence(gameState, player_coordinates,  move_coordinates)\n\n        player_coordinates = move_coordinates\n        player_capacity = int(myPlayer(gameState).backpack_capacity)  \n        ore_capacity = self.GetOreCapacity(gameState.board, target_coordinates)\n        ore_value = self.GetOreValue(gameState.board, target_coordinates)\n\n        while player_capacity <= 8 and ore_capacity > 0:\n            if player_capacity + ore_value > 8:\n                break\n            \n            actions.append(f\"mine {target_coordinates[0]} {target_coordinates[1]}\")\n            player_capacity += ore_value\n            ore_capacity -= 1 \n            \n            self.raw_minerals += 1\n\n        home_coordinates = self.GetHomePosition(gameState)\n\n        actions.extend(self.GoHomeActions(gameState, player_coordinates, home_coordinates))\n        actions.append(self.ConversionXPSplit())\n        self.raw_minerals = 0\n        return actions\n\n    def GetMiningMoneySequence(self, gameState, objectToMine):\n        player_coordinates = self.GetPlayerCordinates(gameState)\n        target_coordinates = self.find_best_ore(gameState.board, objectToMine)\n        move_coordinates = self.find_accessible_neighbor(gameState.board, target_coordinates, player_coordinates)\n        actions = self.get_move_sequence(gameState, player_coordinates,  move_coordinates)\n\n        player_coordinates = move_coordinates\n        player_capacity = int(myPlayer(gameState).backpack_capacity)  \n        ore_capacity = self.GetOreCapacity(gameState.board, target_coordinates)\n        ore_value = self.GetOreValue(gameState.board, target_coordinates)\n\n        while player_capacity <= 8 and ore_capacity > 0:\n            if player_capacity + ore_value > 8:\n                break\n            \n            actions.append(f\"mine {target_coordinates[0]} {target_coordinates[1]}\")\n            player_capacity += ore_value\n            ore_capacity -= 1 \n            \n            self.raw_minerals += 1\n\n        home_coordinates = self.GetHomePosition(gameState)\n\n        actions.extend(self.GoHomeActions(gameState, player_coordinates, home_coordinates))\n        actions.append(self.ConversionMoneySplit())\n        self.raw_minerals = 0\n        return actions\n    \n    def get_move_sequence(self, gameState,  from_coordinates, target_coordinates):\n        search = BreadthFirstSearch(gameState)\n        initial_state = RobotState(gameState, None, from_coordinates, target_coordinates)\n\n        path, _, _ = search.search(lambda: initial_state)\n\n        if path is None:\n            return []\n\n        path.pop(0)\n        return self.create_move_command(path)\n\n    def create_move_command(self, actions):\n        commands = []\n        for action in actions:  \n            commands.append(f\"move {action[0]} {action[1]}\")\n\n        return commands\n\nclass Search(object):\n\n    def __init__(self, gameState):\n        self.board = gameState.board\n        if gameState.firstPlayerTurn:\n            self.player = gameState.player1\n        else:\n            self.player = gameState.player2\n\n    def search(self, initial_state):\n\n        initial_state = initial_state()  \n        states_list = deque([initial_state]) \n        states_set = {initial_state.unique_hash()}  \n\n        processed_list = deque([])  \n        processed_set = set() \n\n        while len(states_list) > 0: \n            curr_state = self.select_state(states_list)  \n            states_set.remove(curr_state.unique_hash())  \n\n            processed_list.append(curr_state) \n            processed_set.add(curr_state.unique_hash())  \n\n            if curr_state.is_final_state():  \n                return Search.reconstruct_path(curr_state), processed_list, states_list\n\n            new_states = curr_state.get_next_states()\n            new_states = [new_state for new_state in new_states if\n                          new_state.unique_hash() not in processed_set and\n                          new_state.unique_hash() not in states_set]\n\n            states_list.extend(new_states)\n\n            states_set.update([new_state.unique_hash() for new_state in new_states])\n        return None, processed_list, states_list\n\n    @staticmethod\n    def reconstruct_path(final_state):\n        path = []\n        while final_state is not None:\n            path.append(final_state.position)\n            final_state = final_state.parent\n        return list(reversed(path))\n\n    @abstractmethod\n    def select_state(self, states):\n        pass\n\nclass BreadthFirstSearch(Search):\n    def select_state(self, states):\n        return states.popleft()     \nclass State(object):\n\n    @abstractmethod\n    def __init__(self, gameState, parent=None, position=None, goal_position=None):\n\n        self.board = gameState.board \n        self.parent = parent \n        self.gameState = gameState\n\n        if self.parent is None:\n            if gameState.firstPlayerTurn:\n                  self.position = position\n                  self.player_code = \"1\"\n                  self.player = gameState.player2\n            else:\n                self.position = position\n                self.player_code = \"2\"\n                self.player = gameState.player2\n            self.goal_position = goal_position  \n        else: \n            self.position = position\n            self.goal_position = goal_position\n            self.player = self.parent.player\n            self.player_code = self.parent.player_code\n\n        self.depth = parent.depth + 1 if parent is not None else 1  \n\n    def get_next_states(self):\n        new_positions = self.get_legal_positions()\n        next_states = []\n        for new_position in new_positions:\n            next_state = self.__class__(self.gameState, self, new_position, self.goal_position)\n            next_states.append(next_state)\n        return next_states\n\n    def get_agent_code(self):\n        return self.player_code\n\n    @abstractmethod\n    def get_legal_positions(self):\n        \"\"\"\n        Apstraktna metoda koja treba da vrati moguce (legalne) sledece pozicije na osnovu trenutne pozicije.\n        :return: list\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def is_final_state(self):\n        \"\"\"\n        Apstraktna metoda koja treba da vrati da li je treuntno stanje zapravo zavrsno stanje.\n        :return: bool\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def unique_hash(self):\n        \"\"\"\n        Apstraktna metoda koja treba da vrati string koji je JEDINSTVEN za ovo stanje\n        (u odnosu na ostala stanja).\n        :return: str\n        \"\"\"\n        pass\n    \n    \n    @abstractmethod\n    def get_current_cost(self):\n        \"\"\"\n        Apstraktna metoda koja treba da vrati stvarnu dosadašnju trenutnu cenu za ovo stanje, odnosno g(n)\n        Koristi se za vodjene pretrage.\n        :return: float\n        \"\"\"\n        pass\nclass RobotState(State):\n\n    def __init__(self, gameState, parent=None, position=None, goal_position=None):\n        super().__init__(gameState, parent, position, goal_position)\n        if parent is None:\n            self.cost = 0\n        else: \n            self.cost = self.parent.cost + 1\n\n    def get_legal_positions(self):\n        retVal = []\n        \n        x = int(self.position[0])\n        y = int(self.position[1])\n        \n        if self.get_agent_code == \"1\":\n            base = \"A\"\n        else:\n            base = \"B\"\n\n        available_fileds = [base, \"E\", self.get_agent_code]\n        if y < 9:\n            for i in range(y + 1, 10):\n                if self.board[x][i] not in available_fileds:\n                    break\n                else:\n                    retVal.append([x, i])\n\n        if y > 0:\n            for i in range(y - 1, -1, -1):\n                if self.board[x][i] not in available_fileds:\n                    break\n                else:\n                    retVal.append([x, i])\n\n        if x < 9:\n            for i in range(x + 1, 10):\n                if self.board[i][y] not in available_fileds:\n                    break\n                else:\n                    retVal.append([i, y])\n\n        if x > 0:\n            for i in range(x - 1, -1, -1):\n                if self.board[i][y] not in available_fileds:\n                    break\n                else:\n                    retVal.append([i, y])\n\n        return retVal\n\n    def is_final_state(self):\n        return self.position == self.goal_position\n\n    def unique_hash(self):\n        return f\"{self.position}{self.player.energy}{self.player.raw_minerals}\"\n\n    def manhattan_distance(self, pointA, pointB):\n        return abs(pointA[0] - pointB[0]) + abs(pointA[1] - pointB[1])\n\n    \n    def get_current_cost(self):\n        return self.cost\n\ndef count_letters_in_matrix(matrix):\n    count_D = 0\n    count_M = 0\n    \n    # Iterate through each row in the matrix\n    for row in matrix:\n        # Iterate through each element in the row\n        for element in row:\n            # Count the occurrences of 'D' and 'M' in the element\n            count_D += element.count('D')\n            count_M += element.count('M')\n\n    return [count_D, count_M]\n\n\n\ndef ValidateDaze(gameState):\n    player = myPlayer(gameState)\n    if(player.coins >= 10 ): \n        return True\n    else:\n        return False\n\ndef is_enemy_nearby(x, y, enemy_position, board_size=10):\n    neighbor_offsets = [\n        (-1, -1), (-1, 0), (-1, 1),\n        (0, -1),         (0, 1),\n        (1, -1), (1, 0), (1, 1)\n    ]\n\n    for dx, dy in neighbor_offsets:\n        neighbor_x = x + dx\n        neighbor_y = y + dy\n        if 0 <= neighbor_x < board_size and 0 <= neighbor_y < board_size:\n            if (neighbor_x, neighbor_y) == enemy_position:\n                return True\n\n    return False\n\nmove_sequence = []\n\ncnt_money = 0\ncnt_xp = 0\ndaze_cnt = 0\ntest_bot_cnt = 0\n\ndef myPlayer(gameState):\n    if gameState.firstPlayerTurn:\n        return gameState.player1\n    else:\n        return gameState.player2\n\ndef enemyPlayer(gameState):\n    if gameState.firstPlayerTurn:\n        return gameState.player2\n    else:\n        return gameState.player1\n\n\nwhile True:\n    line = sys.stdin.readline().strip()\n    json_data = json.loads(line)\n\n    gameState = GameState(json_data)\n\n    player = myPlayer(gameState)\n    enemy = enemyPlayer(gameState)\n\n    if enemy.name == \"Topic Team\":\n        position = enemy.position\n        if(gameState.turn >= 200):\n            if (enemy.position == [0,9] or enemy.position ==[9,0]) and player.xp >= 200:\n                if enemy.daze_turns <= 1:\n                    if(ValidateDaze(gameState)):\n                        move_sequence.insert(0, \"shop daze\")\n        if not move_sequence :\n            move_sequence = player.GetDestroyFactorySequence(gameState)\n\n    ores = count_letters_in_matrix(gameState.board)\n    \n    if not move_sequence and (enemy.processed_diamonds != 0 or enemy.processed_minerals != 0):\n        move_sequence = player.GetDestroyFactorySequence(gameState)\n    elif ores[0] > ores[1] * 2:\n        if not move_sequence:\n            if cnt_money % 3 < 2:\n                move_sequence = player.GetMiningMoneySequence(gameState, 'D')\n                cnt_money += 1\n            else:\n                move_sequence = player.GetMiningMoneySequence(gameState, 'M')\n                cnt_money += 1\n\n    elif ores[1] > 8:\n        if not move_sequence:\n            if cnt_xp % 5 < 4:\n                move_sequence = player.GetMiningSequence(gameState, 'M')\n                cnt_money += 1\n    else: \n        if not move_sequence:\n            move_sequence = player.GetMiningSequence(gameState, 'M')\n\n    if(enemy.name != \"Topic Team\"):\n        if (enemy.position == [0,9] or enemy.position ==[9,0]) and player.xp >= 20 and daze_cnt == 0:\n                if enemy.daze_turns <= 1:\n                    if(ValidateDaze(gameState)):\n                        move_sequence.insert(0, \"shop daze\")\n                    if(ValidateDaze(gameState)):\n                        move_sequence.insert(0, \"shop daze\")\n                        daze_cnt += 1000\n\n    temp = move_sequence.pop(0)\n    if temp.startswith('move') and player.daze_turns != 0:\n        parts= temp.split(' ')\n        targetX= int(parts[1])\n        targetY= int(parts[2])\n        dX= targetX - int(player.position[0])\n        dY= targetY - int(player.position[1])\n        newX= int(player.position[0]) - dX\n        newY= int(player.position[1]) - dY\n        temp=f'move {newX} {newY}'\n\n\n    if temp.startswith('move'):\n        px, py = player.position\n        parts= temp.split(' ')\n        tx = int(parts[1])\n        ty = int(parts[2])\n        ex, ey = enemy.position\n\n        if ((tx - px) * (ey - py) - (ty - py) * (ex - px) == 0 and min(px, tx) <= ex <= max(px, tx) and min(py, ty) <= ey <= max(py, ty)):\n            move_sequence.insert(0, f\"move {tx} {ty}\")\n            #move_sequence.insert(0, \"rest\")\n            #temp = move_sequence.pop(0)\n            print(\"rest\", flush=True)\n            continue\n\n    if(temp.startswith('attack')):\n        attack_parts = temp.split(\" \")\n        x = int(attack_parts[1])\n        y = int(attack_parts[2])\n\n        if is_enemy_nearby(x, y, enemy.position):\n            move_sequence = myPlayer.GetMiningSequence(gameState, 'M')\n            print(\"rest\", flush = True)\n\n    parts = temp.split() \n\n    if len(parts) >= 3: \n        command = parts[0]\n        if(command == \"mine\"):\n            x = int(parts[1])  \n            y = int(parts[2])  \n\n            ore = gameState.board[x][y]\n            prts = ore.split('_')\n            remaining = int(prts[1])\n            if remaining == 0: #invalid komanda za mine\n                move_sequence.clear()\n                move_sequence = player.GetMiningSequence(gameState, \"M\")\n                temp = move_sequence.pop(0)     \n\n    print(temp, flush=True)\n",
        "prediction": "",
        "file": "aibg_hackaton.py"
    },
    {
        "id": 5,
        "prefix": "import sys\nimport time\nimport json\nimport random\nfrom abc import *\nfrom collections import deque\n\nclass GameState:\n    def __init__(self, data):\n        self.turn = int(data['turn'])\n        self.firstPlayerTurn = bool(data['firstPlayerTurn'])\n        self.player1 = Player(data['player1'])\n        self.player2 = Player(data['player2'])\n        self.board = [[str(cell) for cell in row] for row in data['board']]\n\nclass Player:\n    def __init__(self, data):\n        self.name = str(data['name'])\n        self.energy = int(data['energy'])\n        self.xp = int(data['xp'])\n        self.coins = int(data['coins'])\n        self.position = [int(pos) for pos in data['position']]\n        self.increased_backpack_duration = str(data['increased_backpack_duration'])\n        self.daze_turns = int(data['daze_turns'])\n        self.frozen_turns = int(data['frozen_turns'])\n        self.backpack_capacity = int(data['backpack_capacity'])\n        self.raw_minerals = int(data['raw_minerals'])\n        self.processed_minerals = int(data['processed_minerals'])\n        self.raw_diamonds = int(data['raw_diamonds'])\n        self.processed_diamonds = int(data['processed_diamonds'])\n    \n\n    def find_nearest_target(self, board, target_label):\n        min_distance = float('inf')\n        nearest_target_coords = None\n\n        for i in range(len(board)):\n            for j in range(len(board[i])):\n                cell = board[i][j]\n                if isinstance(cell, str) and cell.startswith(target_label):\n                    distance = ((self.position[0] - i) ** 2 + (self.position[1] - j) ** 2) ** 0.5\n                    if distance < min_distance:\n                        min_distance = distance\n                        nearest_target_coords = [i, j] \n\n        return nearest_target_coords\n\n    def find_best_ore(self, board, target_label, value_weight=0.5):\n        best_score = float('-inf')\n        best_ore_coords = None\n\n        for i in range(len(board)):\n            for j in range(len(board[i])):\n                cell = board[i][j]\n                if isinstance(cell, str) and cell.startswith(target_label):\n                    parts = cell.split('_')\n                    if len(parts) >= 3 and int(parts[1]) >= 2:\n                        number1 = int(parts[1])\n                        number2 = int(parts[2])\n\n                        distance = ((self.position[0] - i) ** 2 + (self.position[1] - j) ** 2) ** 0.5\n                        score = number1 + value_weight / (distance + 0.1) \n\n                        if score > best_score:\n                            best_score = score\n                            best_ore_coords = [i, j]\n\n        return best_ore_coords\n\n\n    def find_accessible_neighbor(self, board, target_coords, player_coordinates):\n        target_i, target_j = target_coords\n        player_i, player_j = player_coordinates\n        neighbors = [\n            (target_i - 1, target_j), (target_i + 1, target_j),\n            (target_i, target_j - 1), (target_i, target_j + 1)\n        ]\n\n        closest_neighbor = None\n        min_distance = float('inf')  # Initialize min_distance with infinity\n\n        for ni, nj in neighbors:\n            if 0 <= ni < len(board) and 0 <= nj < len(board[0]):  # Check bounds\n                if board[ni][nj] == 'E':  # Check if the neighbor is accessible\n                    # Calculate Euclidean distance from the neighbor to the player's position\n                    distance = ((ni - player_i) ** 2 + (nj - player_j) ** 2) ** 0.5\n                    if distance < min_distance:\n                        min_distance = distance\n                        closest_neighbor = [ni, nj]\n\n        return closest_neighbor\n\n    def BuildAction(self,x,y):\n        return f'build {x} {y}'\n\n    def RestAction():\n        return 'rest'\n\n    def ShopAction(self,action):\n        return f'shop {action}'\n\n    def AttackAction(self,x,y):\n        return f'attack {x} {y}'\n\n    def ConversionsAction(self,dCoins,mCoins,dEnergy,mEnergy,dXp,mXp):\n        return f\"conv {dCoins} diamond {mCoins} mineral to coins, {dEnergy} diamond {mEnergy} mineral to energy, {dXp} diamond {mXp} mineral to xp\"\n\n    def PutAction(self,X,Y,N,M):\n        return f'refinement-take {X} {Y} mineral {N} diamond {M}'\n\n    def TakeAction(self,X,Y,N,M):\n        return f'refinement-take {X} {Y} mineral {N} diamond {M}'\n\n    def ConversionXPSplit(self):\n        total_minerals = self.raw_minerals\n        total_diamonds = self.raw_diamonds \n\n        if self.energy <= 500:\n            if total_minerals > 2:\n                m_energy =  max(2, total_minerals - 2)\n                m_xp = total_minerals - m_energy \n            else:\n                m_energy = 0 \n                m_xp = total_minerals \n\n            if total_diamonds >= 5:\n                d_xp = max(total_diamonds, 5) \n                d_coins = 0\n            else:\n                d_coins = 0  \n                d_xp = total_diamonds  \n\n            m_coins = 0\n            d_energy = 0\n        else:\n            if total_minerals > 2:\n                m_xp =  max(2, total_minerals - 2)\n                m_energy = total_minerals - m_xp\n            else:\n                m_energy = 0 \n                m_xp = total_minerals \n            if total_diamonds >= 5:\n                d_xp = max(total_diamonds, 5) \n                d_coins = total_diamonds - d_xp \n            else:\n                d_coins = 0  \n                d_xp = total_diamonds    \n\n            m_coins = 0\n            d_energy = 0\n\n        return self.ConversionsAction(d_coins, m_coins, d_energy, m_energy, d_xp, m_xp)\n\n\n    def GetDestroyFactorySequence(self, gameState):\n        player_coordinates = self.GetPlayerCordinates(gameState)\n        target_coordinates = self.find_nearest_target(gameState.board, 'F')\n        if target_coordinates is None: return\n        move_coordinates = self.find_accessible_neighbor(gameState.board, target_coordinates, player_coordinates)\n        actions = self.get_move_sequence(gameState, player_coordinates, move_coordinates)\n\n        factory = gameState.board[target_coordinates[0]][target_coordinates[1]]\n        factory_parts = factory.split('_')\n        counter = int(factory_parts[2])\n        while(counter > 0 ):\n            actions.append(f\"attack {target_coordinates[0]} {target_coordinates[1]}\")\n            counter -= 1\n        return actions\n\n\n    def ConversionMoneySplit(self):\n        total_minerals = self.raw_minerals\n        total_diamonds = self.raw_diamonds \n\n        # Initialize variables with default values\n        d_coins = 0\n        d_xp = 0\n        m_energy = 0\n        m_xp = 0\n        m_coins = 0\n        d_energy = 0\n\n        if self.energy <= 500:\n            if total_minerals >= 2:\n                m_energy = max(2, total_minerals - 2)\n                m_xp = total_minerals - m_energy \n            else:\n                m_xp = total_minerals \n\n            if total_diamonds >= 5:\n                d_xp = total_diamonds\n        else:\n            if total_minerals >= 2:\n                m_xp = max(2, total_minerals - 2)\n                m_energy = total_minerals - m_xp\n            else:\n                m_xp = total_minerals \n\n            d_xp = total_diamonds\n            d_coins = 0\n\n        return self.ConversionsAction(d_coins, m_coins, d_energy, m_energy, d_xp, m_xp)\n\n\n        \n    def GetOreCapacity(self, board, coordinates):\n        ore = board[coordinates[0]][coordinates[1]]\n        parts = ore.split('_')\n        return int(parts[1])\n    \n    def GetOreValue(self, board, coordinates):\n        ore = board[coordinates[0]][coordinates[1]]\n        parts = ore.split('_')\n        return 2 if parts[0] == 'M' else 5\n    \n    def GetHomePosition(self, gameState):\n        return [9,0] if gameState.firstPlayerTurn else [0,9]\n\n    def GoHomeActions(self, gameState, player_coordinates, home_coordinates):\n\n        actions = self.get_move_sequence(gameState, player_coordinates, home_coordinates)\n        if actions is None: return [\"shop daze\"]\n        return actions\n\n    def GetPlayerCordinates(self, gameState):\n        return myPlayer(gameState).position\n\n    def GetMiningSequence(self, gameState, objectToMine):\n        player_coordinates = self.GetPlayerCordinates(gameState)\n        target_coordinates = self.find_best_ore(gameState.board, objectToMine)\n        move_coordinates = self.find_accessible_neighbor(gameState.board, target_coordinates, player_coordinates)\n        actions = self.get_move_sequence(gameState, player_coordinates,  move_coordinates)\n\n        player_coordinates = move_coordinates\n        player_capacity = int(myPlayer(gameState).backpack_capacity)  \n        ore_capacity = self.GetOreCapacity(gameState.board, target_coordinates)\n        ore_value = self.GetOreValue(gameState.board, target_coordinates)\n\n        while player_capacity <= 8 and ore_capacity > 0:\n            if player_capacity + ore_value > 8:\n                break\n            \n            actions.append(f\"",
        "middle": "mine {target_coordinates[0]} {target_coordinates[1]}\")",
        "suffix": "            player_capacity += ore_value\n            ore_capacity -= 1 \n            \n            self.raw_minerals += 1\n\n        home_coordinates = self.GetHomePosition(gameState)\n\n        actions.extend(self.GoHomeActions(gameState, player_coordinates, home_coordinates))\n        actions.append(self.ConversionXPSplit())\n        self.raw_minerals = 0\n        return actions\n\n    def GetMiningMoneySequence(self, gameState, objectToMine):\n        player_coordinates = self.GetPlayerCordinates(gameState)\n        target_coordinates = self.find_best_ore(gameState.board, objectToMine)\n        move_coordinates = self.find_accessible_neighbor(gameState.board, target_coordinates, player_coordinates)\n        actions = self.get_move_sequence(gameState, player_coordinates,  move_coordinates)\n\n        player_coordinates = move_coordinates\n        player_capacity = int(myPlayer(gameState).backpack_capacity)  \n        ore_capacity = self.GetOreCapacity(gameState.board, target_coordinates)\n        ore_value = self.GetOreValue(gameState.board, target_coordinates)\n\n        while player_capacity <= 8 and ore_capacity > 0:\n            if player_capacity + ore_value > 8:\n                break\n            \n            actions.append(f\"mine {target_coordinates[0]} {target_coordinates[1]}\")\n            player_capacity += ore_value\n            ore_capacity -= 1 \n            \n            self.raw_minerals += 1\n\n        home_coordinates = self.GetHomePosition(gameState)\n\n        actions.extend(self.GoHomeActions(gameState, player_coordinates, home_coordinates))\n        actions.append(self.ConversionMoneySplit())\n        self.raw_minerals = 0\n        return actions\n    \n    def get_move_sequence(self, gameState,  from_coordinates, target_coordinates):\n        search = BreadthFirstSearch(gameState)\n        initial_state = RobotState(gameState, None, from_coordinates, target_coordinates)\n\n        path, _, _ = search.search(lambda: initial_state)\n\n        if path is None:\n            return []\n\n        path.pop(0)\n        return self.create_move_command(path)\n\n    def create_move_command(self, actions):\n        commands = []\n        for action in actions:  \n            commands.append(f\"move {action[0]} {action[1]}\")\n\n        return commands\n\nclass Search(object):\n\n    def __init__(self, gameState):\n        self.board = gameState.board\n        if gameState.firstPlayerTurn:\n            self.player = gameState.player1\n        else:\n            self.player = gameState.player2\n\n    def search(self, initial_state):\n\n        initial_state = initial_state()  \n        states_list = deque([initial_state]) \n        states_set = {initial_state.unique_hash()}  \n\n        processed_list = deque([])  \n        processed_set = set() \n\n        while len(states_list) > 0: \n            curr_state = self.select_state(states_list)  \n            states_set.remove(curr_state.unique_hash())  \n\n            processed_list.append(curr_state) \n            processed_set.add(curr_state.unique_hash())  \n\n            if curr_state.is_final_state():  \n                return Search.reconstruct_path(curr_state), processed_list, states_list\n\n            new_states = curr_state.get_next_states()\n            new_states = [new_state for new_state in new_states if\n                          new_state.unique_hash() not in processed_set and\n                          new_state.unique_hash() not in states_set]\n\n            states_list.extend(new_states)\n\n            states_set.update([new_state.unique_hash() for new_state in new_states])\n        return None, processed_list, states_list\n\n    @staticmethod\n    def reconstruct_path(final_state):\n        path = []\n        while final_state is not None:\n            path.append(final_state.position)\n            final_state = final_state.parent\n        return list(reversed(path))\n\n    @abstractmethod\n    def select_state(self, states):\n        pass\n\nclass BreadthFirstSearch(Search):\n    def select_state(self, states):\n        return states.popleft()     \nclass State(object):\n\n    @abstractmethod\n    def __init__(self, gameState, parent=None, position=None, goal_position=None):\n\n        self.board = gameState.board \n        self.parent = parent \n        self.gameState = gameState\n\n        if self.parent is None:\n            if gameState.firstPlayerTurn:\n                  self.position = position\n                  self.player_code = \"1\"\n                  self.player = gameState.player2\n            else:\n                self.position = position\n                self.player_code = \"2\"\n                self.player = gameState.player2\n            self.goal_position = goal_position  \n        else: \n            self.position = position\n            self.goal_position = goal_position\n            self.player = self.parent.player\n            self.player_code = self.parent.player_code\n\n        self.depth = parent.depth + 1 if parent is not None else 1  \n\n    def get_next_states(self):\n        new_positions = self.get_legal_positions()\n        next_states = []\n        for new_position in new_positions:\n            next_state = self.__class__(self.gameState, self, new_position, self.goal_position)\n            next_states.append(next_state)\n        return next_states\n\n    def get_agent_code(self):\n        return self.player_code\n\n    @abstractmethod\n    def get_legal_positions(self):\n        \"\"\"\n        Apstraktna metoda koja treba da vrati moguce (legalne) sledece pozicije na osnovu trenutne pozicije.\n        :return: list\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def is_final_state(self):\n        \"\"\"\n        Apstraktna metoda koja treba da vrati da li je treuntno stanje zapravo zavrsno stanje.\n        :return: bool\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def unique_hash(self):\n        \"\"\"\n        Apstraktna metoda koja treba da vrati string koji je JEDINSTVEN za ovo stanje\n        (u odnosu na ostala stanja).\n        :return: str\n        \"\"\"\n        pass\n    \n    \n    @abstractmethod\n    def get_current_cost(self):\n        \"\"\"\n        Apstraktna metoda koja treba da vrati stvarnu dosadašnju trenutnu cenu za ovo stanje, odnosno g(n)\n        Koristi se za vodjene pretrage.\n        :return: float\n        \"\"\"\n        pass\nclass RobotState(State):\n\n    def __init__(self, gameState, parent=None, position=None, goal_position=None):\n        super().__init__(gameState, parent, position, goal_position)\n        if parent is None:\n            self.cost = 0\n        else: \n            self.cost = self.parent.cost + 1\n\n    def get_legal_positions(self):\n        retVal = []\n        \n        x = int(self.position[0])\n        y = int(self.position[1])\n        \n        if self.get_agent_code == \"1\":\n            base = \"A\"\n        else:\n            base = \"B\"\n\n        available_fileds = [base, \"E\", self.get_agent_code]\n        if y < 9:\n            for i in range(y + 1, 10):\n                if self.board[x][i] not in available_fileds:\n                    break\n                else:\n                    retVal.append([x, i])\n\n        if y > 0:\n            for i in range(y - 1, -1, -1):\n                if self.board[x][i] not in available_fileds:\n                    break\n                else:\n                    retVal.append([x, i])\n\n        if x < 9:\n            for i in range(x + 1, 10):\n                if self.board[i][y] not in available_fileds:\n                    break\n                else:\n                    retVal.append([i, y])\n\n        if x > 0:\n            for i in range(x - 1, -1, -1):\n                if self.board[i][y] not in available_fileds:\n                    break\n                else:\n                    retVal.append([i, y])\n\n        return retVal\n\n    def is_final_state(self):\n        return self.position == self.goal_position\n\n    def unique_hash(self):\n        return f\"{self.position}{self.player.energy}{self.player.raw_minerals}\"\n\n    def manhattan_distance(self, pointA, pointB):\n        return abs(pointA[0] - pointB[0]) + abs(pointA[1] - pointB[1])\n\n    \n    def get_current_cost(self):\n        return self.cost\n\ndef count_letters_in_matrix(matrix):\n    count_D = 0\n    count_M = 0\n    \n    # Iterate through each row in the matrix\n    for row in matrix:\n        # Iterate through each element in the row\n        for element in row:\n            # Count the occurrences of 'D' and 'M' in the element\n            count_D += element.count('D')\n            count_M += element.count('M')\n\n    return [count_D, count_M]\n\n\n\ndef ValidateDaze(gameState):\n    player = myPlayer(gameState)\n    if(player.coins >= 10 ): \n        return True\n    else:\n        return False\n\ndef is_enemy_nearby(x, y, enemy_position, board_size=10):\n    neighbor_offsets = [\n        (-1, -1), (-1, 0), (-1, 1),\n        (0, -1),         (0, 1),\n        (1, -1), (1, 0), (1, 1)\n    ]\n\n    for dx, dy in neighbor_offsets:\n        neighbor_x = x + dx\n        neighbor_y = y + dy\n        if 0 <= neighbor_x < board_size and 0 <= neighbor_y < board_size:\n            if (neighbor_x, neighbor_y) == enemy_position:\n                return True\n\n    return False\n\nmove_sequence = []\n\ncnt_money = 0\ncnt_xp = 0\ndaze_cnt = 0\ntest_bot_cnt = 0\n\ndef myPlayer(gameState):\n    if gameState.firstPlayerTurn:\n        return gameState.player1\n    else:\n        return gameState.player2\n\ndef enemyPlayer(gameState):\n    if gameState.firstPlayerTurn:\n        return gameState.player2\n    else:\n        return gameState.player1\n\n\nwhile True:\n    line = sys.stdin.readline().strip()\n    json_data = json.loads(line)\n\n    gameState = GameState(json_data)\n\n    player = myPlayer(gameState)\n    enemy = enemyPlayer(gameState)\n\n    if enemy.name == \"Topic Team\":\n        position = enemy.position\n        if(gameState.turn >= 200):\n            if (enemy.position == [0,9] or enemy.position ==[9,0]) and player.xp >= 200:\n                if enemy.daze_turns <= 1:\n                    if(ValidateDaze(gameState)):\n                        move_sequence.insert(0, \"shop daze\")\n        if not move_sequence :\n            move_sequence = player.GetDestroyFactorySequence(gameState)\n\n    ores = count_letters_in_matrix(gameState.board)\n    \n    if not move_sequence and (enemy.processed_diamonds != 0 or enemy.processed_minerals != 0):\n        move_sequence = player.GetDestroyFactorySequence(gameState)\n    elif ores[0] > ores[1] * 2:\n        if not move_sequence:\n            if cnt_money % 3 < 2:\n                move_sequence = player.GetMiningMoneySequence(gameState, 'D')\n                cnt_money += 1\n            else:\n                move_sequence = player.GetMiningMoneySequence(gameState, 'M')\n                cnt_money += 1\n\n    elif ores[1] > 8:\n        if not move_sequence:\n            if cnt_xp % 5 < 4:\n                move_sequence = player.GetMiningSequence(gameState, 'M')\n                cnt_money += 1\n    else: \n        if not move_sequence:\n            move_sequence = player.GetMiningSequence(gameState, 'M')\n\n    if(enemy.name != \"Topic Team\"):\n        if (enemy.position == [0,9] or enemy.position ==[9,0]) and player.xp >= 20 and daze_cnt == 0:\n                if enemy.daze_turns <= 1:\n                    if(ValidateDaze(gameState)):\n                        move_sequence.insert(0, \"shop daze\")\n                    if(ValidateDaze(gameState)):\n                        move_sequence.insert(0, \"shop daze\")\n                        daze_cnt += 1000\n\n    temp = move_sequence.pop(0)\n    if temp.startswith('move') and player.daze_turns != 0:\n        parts= temp.split(' ')\n        targetX= int(parts[1])\n        targetY= int(parts[2])\n        dX= targetX - int(player.position[0])\n        dY= targetY - int(player.position[1])\n        newX= int(player.position[0]) - dX\n        newY= int(player.position[1]) - dY\n        temp=f'move {newX} {newY}'\n\n\n    if temp.startswith('move'):\n        px, py = player.position\n        parts= temp.split(' ')\n        tx = int(parts[1])\n        ty = int(parts[2])\n        ex, ey = enemy.position\n\n        if ((tx - px) * (ey - py) - (ty - py) * (ex - px) == 0 and min(px, tx) <= ex <= max(px, tx) and min(py, ty) <= ey <= max(py, ty)):\n            move_sequence.insert(0, f\"move {tx} {ty}\")\n            #move_sequence.insert(0, \"rest\")\n            #temp = move_sequence.pop(0)\n            print(\"rest\", flush=True)\n            continue\n\n    if(temp.startswith('attack')):\n        attack_parts = temp.split(\" \")\n        x = int(attack_parts[1])\n        y = int(attack_parts[2])\n\n        if is_enemy_nearby(x, y, enemy.position):\n            move_sequence = myPlayer.GetMiningSequence(gameState, 'M')\n            print(\"rest\", flush = True)\n\n    parts = temp.split() \n\n    if len(parts) >= 3: \n        command = parts[0]\n        if(command == \"mine\"):\n            x = int(parts[1])  \n            y = int(parts[2])  \n\n            ore = gameState.board[x][y]\n            prts = ore.split('_')\n            remaining = int(prts[1])\n            if remaining == 0: #invalid komanda za mine\n                move_sequence.clear()\n                move_sequence = player.GetMiningSequence(gameState, \"M\")\n                temp = move_sequence.pop(0)     \n\n    print(temp, flush=True)\n",
        "prediction": "",
        "file": "aibg_hackaton.py"
    },
    {
        "id": 6,
        "prefix": "import numpy as np\nfrom collections import defaultdict\n\nclass Player:\n    def __init__(self, name):\n        self.name = name\n        self.hand = defaultdict(int)\n        self.cards_won = defaultdict(int)\n        self.points = 0\n\n    def draw_card(self, card):\n        self.hand[card] += 1\n\n    def play_card(self, card):\n        if self.hand[card] > 0:\n            self.hand[card] -= 1\n            return card\n\n\n    def need_cards(self):\n        return sum(self.hand.values()) < 4\n\n    def card_count(self):\n        return sum(self.hand.values())\n\n    def add_won_cards(self, cards):\n        for card, count in cards.items():\n            self.cards_won[card] += count\n            if card in ['10', 'A']:\n                self.points += 10 * count\n\n    def show_hand(self):\n        return {card: count for card, count in self.hand.items() if count > 0}\n\n    def show_won_cards(self):\n        return {card: count for card, count in self.cards_won.items() if count > 0}\n\n\nimport random\nfrom collections import defaultdict\nfrom player import Player\n\nclass CardGame:\n    def __init__(self, player_names):\n        self.players = [Player(name) for name in player_names]\n        self.deck = self.create_deck()\n        self.pile = defaultdict(int)\n        self.pile_winner_index = 0\n        self.first_player_index = 0\n        self.current_player_index = 0\n        self.first_card_played = None\n        self.deal_cards()\n\n    def create_deck(self):\n        cards = ['7', '8', '9', '10', 'J', 'Q', 'K', 'A']\n        deck = [card for card in cards for _ in range(4)]\n        random.shuffle(deck)\n        return deck\n\n    def deal_cards(self):\n      while any(player.need_cards() for player in self.players) and self.deck:\n          for player in self.players:\n              if player.need_cards() and self.deck:\n                  player.draw_card(self.deck.pop())\n\n    def reset(self):\n        self.deck = self.create_deck()\n        self.pile = defaultdict(int)\n        self.pile_winner_index = 0\n        self.first_card_played = None\n        self.first_player_index = 0\n        self.current_player_index = 0\n        for player in self.players:\n            player.hand = defaultdict(int)\n            player.cards_won = defaultdict(int)\n            player.points = 0\n        self.deal_cards()\n\n    def step(self, card):\n      needs_to_play_again = False\n      info = {\n        'invalid_move': False,\n        'reason': ''\n    }\n      if card == 'END':\n          if self.current_player_index != self.first_player_index:\n              reward = -1000\n              done = True\n              info['invalid_move'] = True\n              info['reason'] = 'Played END but not played first'\n              return reward, done, needs_to_play_again, info\n          elif self.first_card_played is None:\n              reward = -1000\n              done = True\n              info['invalid_move'] = True\n              info['reason'] = 'Played END on first turn'\n              return reward, done, needs_to_play_again, info\n          else:\n              reward, done, needs_to_play_again = self._end_round()\n              reward += 5\n              self.current_player_index = self.pile_winner_index\n              return reward, done, needs_to_play_again, info\n\n\n      if (self.current_player_index == self.first_player_index) and self.first_card_played is not None:\n          if card != self.first_card_played and card != '7':\n              reward = -1000\n              done = True\n              info['invalid_move'] = True\n              info['reason'] = 'Tried to continue round with invalid card'\n              return reward, done, needs_to_play_again, info\n\n      if self.players[self.current_player_index].hand[card] <= 0:\n          reward = -1000\n          done = True\n          info['invalid_move'] = True\n          info['reason'] = 'Card not available in hand'\n          return reward, done, needs_to_play_again, info\n\n      self.players[self.current_player_index].play_card(card)\n      self.pile[card] += 1\n\n      if self.first_card_played is None:\n          self.first_card_played = card\n          self.pile_winner_index = self.current_player_index\n          self.first_player_index = self.current_player_index\n      else:\n          if card == self.first_card_played or card == '7':\n              self.pile_winner_index = self.current_player_index\n\n\n      if not needs_to_play_again:\n        self._next_turn()\n\n      reward = 5\n      done = self._check_game_over()\n      return reward, done, needs_to_play_again, info\n\n    def _next_turn(self):\n        self.current_player_index = (self.current_player_index + 1) % 2\n\n    def _end_round(self):\n        self.players[self.pile_winner_index].add_won_cards(self.pile)\n        reward = (self.pile['10'] + self.pile['A']) * 10 + 5\n\n        self.pile = defaultdict(int)\n        self.first_card_played = None\n\n        needs_to_play_again = False\n        if self.first_player_index == self.pile_winner_index:\n          needs_to_play_again = True\n\n        self.first_player_index = self.pile_winner_index\n        done = self._check_game_over()\n        if not done:\n          self.deal_cards()\n\n        return reward, done, needs_to_play_again\n\n    def play_opponent_move(self):\n        opponent = self.players[self.current_player_index]\n        valid_cards = []\n\n        if (self.current_player_index == self.first_player_index) and self.first_card_played is not None:\n            valid_cards = [card for card, count in opponent.hand.items() if count > 0 and (card == '7' or card == self.first_card_played)]\n            valid_cards.append('END')\n        else:\n            valid_cards = [card for card in opponent.hand if opponent.hand[card] > 0]\n\n        choic",
        "middle": "e = random.choice(valid_cards)",
        "suffix": "\n        _, done, needs_again, _ = self.step(choice)\n        return done, needs_again\n\n\n    def winner_reward(self):\n      bonus = 0\n      if self._check_game_over():\n        if self.players[0].points > self.players[1].points:\n          bonus = 50\n        if self.players[0].points < self.players[1].points:\n          bonus = -30\n\n      return bonus\n\n\n\n    def _check_game_over(self):\n        if len(self.deck) == 0 and all(player.card_count() == 0 for player in self.players):\n            return True\n        return False\n\n\nimport gym\nfrom gym import spaces\nfrom collections import defaultdict\nimport random\nfrom game import CardGame\n\nclass PlayerEnv(gym.Env):\n    def __init__(self, game_state):\n        super(PlayerEnv, self).__init__()\n        self.game_state = game_state\n        self.action_space = spaces.Discrete(9)  # 8 different cards and one 'END' action\n        self.observation_space = spaces.Box(low=0, high=52, shape=(8 + 8 + 8 + 2 + 1,), dtype=int)  # player's hand, pile on the table, won cards, points, first card in pile\n\n    def reset(self):\n        self.game_state.reset()\n        return self._get_obs()\n\n    def step(self, action):\n        card = self._action_to_card(action)\n        reward, done, needs_to_play_again, info = self.game_state.step(card)\n        if not done and not needs_to_play_again:\n            done, needs_again_opponent = self.game_state.play_opponent_move()\n            if not done and needs_again_opponent:\n                done, _ = self.game_state.play_opponent_move()\n\n        if done:\n            reward += self.game_state.winner_reward()\n\n        return self._get_obs(), reward, done, info\n\n    def render(self, mode='human'):\n        print(f\"\\n{'='*20} GAME STATE {'='*20}\")\n\n        for i, player in enumerate(self.game_state.players):\n            print(f\"Player {i+1} ({player.name}):\")\n            print(f\"  Hand: {player.show_hand()}\")\n            print(f\"  Won Cards: {player.show_won_cards()}\")\n            print(f\"  Points: {player.points}\")\n            print('-' * 50)\n\n        print(f\"Pile: {dict(self.game_state.pile)}\")\n        print(f\"First Card Played: {self.game_state.first_card_played}\")\n        print('='*50)\n\n    def close(self):\n        pass\n\n    def _get_obs(self):\n        obs = []\n\n        # player's cards\n        player = self.game_state.players[0]\n        obs.extend([player.hand[card] for card in ['7', '8', '9', '10', 'J', 'Q', 'K', 'A']])\n\n        # pile\n        obs.extend([self.game_state.pile[card] for card in ['7', '8', '9', '10', 'J', 'Q', 'K', 'A']])\n\n        # won cards\n        combined_won_cards = defaultdict(int)\n        for p in self.game_state.players:\n            for card, count in p.cards_won.items():\n                combined_won_cards[card] += count\n        obs.extend([combined_won_cards[card] for card in ['7', '8', '9', '10', 'J', 'Q', 'K', 'A']])\n\n        # points of both players\n        for p in self.game_state.players:\n            obs.append(p.points)\n\n        # first card in pile\n        first_card_index = self._card_to_index(self.game_state.first_card_played)\n        obs.append(first_card_index)\n\n        return np.array(obs, dtype=np.int32)\n\n    def _action_to_card(self, action):\n        card_map = ['7', '8', '9', '10', 'J', 'Q', 'K', 'A', 'END']\n        if action == 8:\n            return 'END'\n        return card_map[action]\n\n    def _card_to_index(self, card):\n        card_map = ['7', '8', '9', '10', 'J', 'Q', 'K', 'A']\n        if card is None:\n            return -1  # no card on table\n        return card_map.index(card)\n",
        "prediction": "",
        "file": "openai_gym_env.py"
    },
    {
        "id": 7,
        "prefix": "import numpy as np\nfrom collections import defaultdict\n\nclass Player:\n    def __init__(self, name):\n        self.name = name\n        self.hand = defaultdict(int)\n        self.cards_won = defaultdict(int)\n        self.points = 0\n\n    def draw_card(self, card):\n        self.hand[card] += 1\n\n    def play_card(self, card):\n        if self.hand[card] > 0:\n            self.hand[card] -= 1\n            return card\n\n\n    def need_cards(self):\n        return sum(self.hand.values()) < 4\n\n    def card_count(self):\n        return sum(self.hand.values())\n\n    def add_won_cards(self, cards):\n        for card, count in cards.items():\n            self.cards_won[card] += count\n            if card in ['10', 'A']:\n                self.points += 10 * count\n\n    def show_hand(self):\n        return {card: count for card, count in self.hand.items() if count > 0}\n\n    def show_won_cards(self):\n        return {card: count for card, count in self.cards_won.items() if count > 0}\n\n\nimport random\nfrom collections import defaultdict\nfrom player import Player\n\nclass CardGame:\n    def __init__(self, player_names):\n        self.players = [Player(name) for name in player_names]\n        self.deck = self.create_deck()\n        self.pile = defaultdict(int)\n        self.pile_winner_index = 0\n        self.first_player_index = 0\n        self.current_player_index = 0\n        self.first_card_played = None\n        self.deal_cards()\n\n    def create_deck(self):\n        cards = ['7', '8', '9', '10', 'J', 'Q', 'K', 'A']\n        deck = [card for card in cards for _ in range(4)]\n        random.shuffle(deck)\n        return deck\n\n    def deal_cards(self):\n      while any(player.need_cards() for player in self.players) and self.deck:\n          for player in self.players:\n              if player.need_cards() and self.deck:\n                  player.draw_card(self.deck.pop())\n\n    def reset(self):\n        self.deck = self.create_deck()\n        self.pile = defaultdict(int)\n        self.pile_winner_index = 0\n        self.first_card_played = None\n        self.first_player_index = 0\n        self.current_player_index = 0\n        for player in self.players:\n            player.hand = defaultdict(int)\n            player.cards_won = defaultdict(int)\n            player.points = 0\n        self.deal_cards()\n\n    def step(self, card):\n      needs_to_play_again = False\n      info = {\n        'invalid_move': False,\n        'reason': ''\n    }\n      if card == 'END':\n          if self.current_player_index != self.first_player_index:\n              reward = -1000\n              done = True\n              info['invalid_move'] = True\n              info['reason'] = 'Played END but not played first'\n              return reward, done, needs_to_play_again, info\n          elif self.first_card_played is None:\n              reward = -1000\n              done = True\n              info['invalid_move'] = True\n              info['reason'] = 'Played END on first turn'\n              return reward, done, needs_to_play_again, info\n          else:\n              reward, done, needs_to_play_again = self._end_round()\n              reward += 5\n              self.current_player_index = self.pile_winner_index\n              return reward, done, needs_to_play_again, info\n\n\n      if (self.current_player_index == self.first_player_index) and self.first_card_played is not None:\n          if card != self.first_card_played and card != '7':\n              reward = -1000\n              done = True\n              info['invalid_move'] = True\n              info['reason'] = 'Tried to continue round with invalid card'\n              return reward, done, needs_to_play_again, info\n\n      if self.players[self.current_player_index].hand[card] <= 0:\n          reward = -1000\n          done = True\n          info['invalid_move'] = True\n          info['reason'] = 'Card not available in hand'\n          return reward, done, needs_to_play_again, info\n\n      self.players[self.current_player_index].play_card(card)\n      self.pile[card] += 1\n\n      if self.first_card_played is None:\n          self.first_card_played = card\n          self.pile_winner_index = self.current_player_index\n          self.first_player_index = self.current_player_index\n      else:\n          if card == self.first_card_played or card == '7':\n              self.pile_winner_index = self.current_player_index\n\n\n      if not needs_to_play_again:\n        self._next_turn()\n\n      reward = 5\n      done = self._check_game_over()\n      return reward, done, needs_to_play_again, info\n\n    def _next_turn(self):\n        self.current_player_index = (self.current_player_index + 1) % 2\n\n    def _end_round(self):\n        self.players[self.pile_winner_index].add_won_cards(self.pile)\n        reward = (self.pile['10'] + self.pile['A']) * 10 + 5\n\n        self.pile = defaultdict(int)\n        self.first_card_played = None\n\n        needs_to_play_again = False\n        if self.first_player_index == self.pile_winner_index:\n          needs_to_play_again = True\n\n        self.first_player_index = self.pile_winner_index\n        done = self._check_game_over()\n        if not done:\n          self.deal_cards()\n\n        return reward, done, needs_to_play_again\n\n    def play_opponent_move(self):\n        opponent = self.players[self.current_player_index]\n        valid_cards = []\n\n        if (self.current_player_index == self.first_player_index) and self.first_card_played is not None:\n            valid_cards = [card for card, count in opponent.hand.items() if count > 0 and (card == '7' or card == self.first_card_played)]\n            valid_cards.append('END')\n        else:\n            valid_cards = [card for card in opponent.hand if opponent.hand[card] > 0]\n\n        choice = random.choice(valid_cards)\n\n        _, done, needs_again, _ = self.step(choice)\n        return done, needs_again\n\n\n    def winner_reward(self):\n      bonus = 0\n      if self._check_game_over():\n        if self.players[0].points > self.players[1].points:\n          bonus = 50\n        if self.players[0].points < self.players[1].points:\n          bonus = -30\n\n      return bonus\n\n\n\n    def _check_game_over(self):\n        if len(self.deck) == 0 and all(player.card_count() == 0 for player in self.players):\n            return True\n        return False\n\n\nimport gym\nfrom gym import spaces\nfrom collections import defaultdict\nimport random\nfrom game import CardGame\n\nclass PlayerEnv(gym.Env):\n    def __init__(self, game_state):\n        super(PlayerEnv, self).__init__()\n        self.game_state = game_state\n        self.action_space = spaces.Discrete(9)  # 8 different cards and one 'END' action\n        self.observation_space = spaces.Box(low=0, high=52, shape=(8 + 8 + 8 + 2 + 1,), dtype=int)  # player's hand, pile on the table, won cards, points, first card in pile\n\n    def reset(self):\n        self.game_state.reset()\n        return self._get_obs()\n\n    def step(self, action):\n        card = self._action_to_card(action)\n        reward, done, needs_to_play_again, info = self.game_state.step(card)\n        if not done and not needs_to_play_again:\n            done, needs_again_opponent = self.game_state.play_opponent_move()\n            if not done and needs_again_opponent:\n                done, _ = self.game_state.play_opponent_move()\n\n        if done:\n            reward += self.game_state.winner_reward()\n\n        return self._get_obs(), reward, done, info\n\n    def render(self, mode='human'):\n        print(f\"\\n{'='*20} GAME STATE {'='*20}\")\n\n        for i, player in enumerate(self.game_state.players):\n            print(f\"Player {i+1} ({player.name}):\")\n            print(f\"  Hand: {player.show_hand()}\")\n            print(f\"  Won Cards: {player.show_won_cards()}\")\n            print(f\"  Points: {player.points}\")\n            print('-' * 50)\n\n        print(f\"Pile: {dict(self.game_state.pile)}\")\n        print(f\"First Card Played: {self.game_state.first_card_played}\")\n ",
        "middle": "       print('='*50)",
        "suffix": "\n    def close(self):\n        pass\n\n    def _get_obs(self):\n        obs = []\n\n        # player's cards\n        player = self.game_state.players[0]\n        obs.extend([player.hand[card] for card in ['7', '8', '9', '10', 'J', 'Q', 'K', 'A']])\n\n        # pile\n        obs.extend([self.game_state.pile[card] for card in ['7', '8', '9', '10', 'J', 'Q', 'K', 'A']])\n\n        # won cards\n        combined_won_cards = defaultdict(int)\n        for p in self.game_state.players:\n            for card, count in p.cards_won.items():\n                combined_won_cards[card] += count\n        obs.extend([combined_won_cards[card] for card in ['7', '8', '9', '10', 'J', 'Q', 'K', 'A']])\n\n        # points of both players\n        for p in self.game_state.players:\n            obs.append(p.points)\n\n        # first card in pile\n        first_card_index = self._card_to_index(self.game_state.first_card_played)\n        obs.append(first_card_index)\n\n        return np.array(obs, dtype=np.int32)\n\n    def _action_to_card(self, action):\n        card_map = ['7', '8', '9', '10', 'J', 'Q', 'K', 'A', 'END']\n        if action == 8:\n            return 'END'\n        return card_map[action]\n\n    def _card_to_index(self, card):\n        card_map = ['7', '8', '9', '10', 'J', 'Q', 'K', 'A']\n        if card is None:\n            return -1  # no card on table\n        return card_map.index(card)\n",
        "prediction": "",
        "file": "openai_gym_env.py"
    },
    {
        "id": 8,
        "prefix": "import numpy as np\nfrom collections import defaultdict\n\nclass Player:\n    def __init__(self, name):\n        self.name = name\n        self.hand = defaultdict(int)\n        self.cards_won = defaultdict(int)\n        self.points = 0\n\n    def draw_card(self, card):\n        self.hand[card] += 1\n\n    def play_card(self, card):\n        if self.hand[card] > 0:\n            self.hand[card] -= 1\n            return card\n\n\n    def need_cards(self):\n        return sum(self.hand.values()) < 4\n\n    def card_count(self):\n        return sum(self.hand.values())\n\n    def add_won_cards(self, cards):\n        for card, count in cards.items():\n            self.cards_won[card] += count\n            if card in ['10', 'A']:\n                self.points += 10 * count\n\n    def show_hand(self):\n        return {card: count for card, count in self.hand.items() if count > 0}\n\n    def show_won_cards(self):\n        return {card: count for card, count in self.cards_won.items() if count > 0}\n\n\nimport random\nfrom collections import defaultdict\nfrom player import Player\n\nclass CardGame:\n    def __init__(self, player_names):\n        self.players = [Player(name) for name in player_names]\n        self.deck = self.create_deck()\n        self.pile = defaultdict(int)\n        self.pile_winner_index = 0\n        self.first_player_index = 0\n        self.current_player_index = 0\n        self.first_card_played = None\n        self.deal_cards()\n\n    def create_deck(self):\n        cards = ['7', '8', '9', '10', 'J', 'Q', 'K', 'A']\n        deck = [card for card in cards for _ in range(4)]\n        random.shuffle(deck)\n        return deck\n\n    def deal_cards(self):\n      while any(player.need_cards() for player in self.players) and self.deck:\n          for player in self.players:\n              if player.need_cards() and self.deck:\n                  player.draw_card(self.deck.pop())\n\n    def reset(self):\n        self.deck = self.create_deck()\n        self.pile = defaultdict(int)\n        self.pile_winner_index = 0\n        self.first_card_played = None\n        self.first_player_index = 0\n        self.current_player_index = 0\n        for player in self.players:\n            player.hand = defaultdict(int)\n            player.cards_won = defaultdict(int)\n            player.points = 0\n        self.deal_cards()\n\n    def step(self, card):\n      needs_to_play_again = False\n      info = {\n        'invalid_move': False,\n        'reason': ''\n    }\n      if card == 'END':\n          if self.current_player_index != self.first_player_index:\n              reward = -1000\n              done = True\n              info['invalid_move'] = True\n              info['reason'] = 'Played END but not played first'\n              return reward, done, needs_to_play_again, info\n          elif self.first_card_played is None:\n              reward = -1000\n              done = True\n              info['invalid_move'] = True\n              info['reason'] = 'Played END on first turn'\n              return reward, done, needs_to_play_again, info\n          else:\n              reward, done, needs_to_play_again = self._end_round()\n              reward += 5\n              self.current_player_index = self.pile_winner_index\n              return reward, done, needs_to_play_again, info\n\n\n      if (self.current_playe",
        "middle": "r_index == self.first_player_index) and self.first_card_played is not None:",
        "suffix": "          if card != self.first_card_played and card != '7':\n              reward = -1000\n              done = True\n              info['invalid_move'] = True\n              info['reason'] = 'Tried to continue round with invalid card'\n              return reward, done, needs_to_play_again, info\n\n      if self.players[self.current_player_index].hand[card] <= 0:\n          reward = -1000\n          done = True\n          info['invalid_move'] = True\n          info['reason'] = 'Card not available in hand'\n          return reward, done, needs_to_play_again, info\n\n      self.players[self.current_player_index].play_card(card)\n      self.pile[card] += 1\n\n      if self.first_card_played is None:\n          self.first_card_played = card\n          self.pile_winner_index = self.current_player_index\n          self.first_player_index = self.current_player_index\n      else:\n          if card == self.first_card_played or card == '7':\n              self.pile_winner_index = self.current_player_index\n\n\n      if not needs_to_play_again:\n        self._next_turn()\n\n      reward = 5\n      done = self._check_game_over()\n      return reward, done, needs_to_play_again, info\n\n    def _next_turn(self):\n        self.current_player_index = (self.current_player_index + 1) % 2\n\n    def _end_round(self):\n        self.players[self.pile_winner_index].add_won_cards(self.pile)\n        reward = (self.pile['10'] + self.pile['A']) * 10 + 5\n\n        self.pile = defaultdict(int)\n        self.first_card_played = None\n\n        needs_to_play_again = False\n        if self.first_player_index == self.pile_winner_index:\n          needs_to_play_again = True\n\n        self.first_player_index = self.pile_winner_index\n        done = self._check_game_over()\n        if not done:\n          self.deal_cards()\n\n        return reward, done, needs_to_play_again\n\n    def play_opponent_move(self):\n        opponent = self.players[self.current_player_index]\n        valid_cards = []\n\n        if (self.current_player_index == self.first_player_index) and self.first_card_played is not None:\n            valid_cards = [card for card, count in opponent.hand.items() if count > 0 and (card == '7' or card == self.first_card_played)]\n            valid_cards.append('END')\n        else:\n            valid_cards = [card for card in opponent.hand if opponent.hand[card] > 0]\n\n        choice = random.choice(valid_cards)\n\n        _, done, needs_again, _ = self.step(choice)\n        return done, needs_again\n\n\n    def winner_reward(self):\n      bonus = 0\n      if self._check_game_over():\n        if self.players[0].points > self.players[1].points:\n          bonus = 50\n        if self.players[0].points < self.players[1].points:\n          bonus = -30\n\n      return bonus\n\n\n\n    def _check_game_over(self):\n        if len(self.deck) == 0 and all(player.card_count() == 0 for player in self.players):\n            return True\n        return False\n\n\nimport gym\nfrom gym import spaces\nfrom collections import defaultdict\nimport random\nfrom game import CardGame\n\nclass PlayerEnv(gym.Env):\n    def __init__(self, game_state):\n        super(PlayerEnv, self).__init__()\n        self.game_state = game_state\n        self.action_space = spaces.Discrete(9)  # 8 different cards and one 'END' action\n        self.observation_space = spaces.Box(low=0, high=52, shape=(8 + 8 + 8 + 2 + 1,), dtype=int)  # player's hand, pile on the table, won cards, points, first card in pile\n\n    def reset(self):\n        self.game_state.reset()\n        return self._get_obs()\n\n    def step(self, action):\n        card = self._action_to_card(action)\n        reward, done, needs_to_play_again, info = self.game_state.step(card)\n        if not done and not needs_to_play_again:\n            done, needs_again_opponent = self.game_state.play_opponent_move()\n            if not done and needs_again_opponent:\n                done, _ = self.game_state.play_opponent_move()\n\n        if done:\n            reward += self.game_state.winner_reward()\n\n        return self._get_obs(), reward, done, info\n\n    def render(self, mode='human'):\n        print(f\"\\n{'='*20} GAME STATE {'='*20}\")\n\n        for i, player in enumerate(self.game_state.players):\n            print(f\"Player {i+1} ({player.name}):\")\n            print(f\"  Hand: {player.show_hand()}\")\n            print(f\"  Won Cards: {player.show_won_cards()}\")\n            print(f\"  Points: {player.points}\")\n            print('-' * 50)\n\n        print(f\"Pile: {dict(self.game_state.pile)}\")\n        print(f\"First Card Played: {self.game_state.first_card_played}\")\n        print('='*50)\n\n    def close(self):\n        pass\n\n    def _get_obs(self):\n        obs = []\n\n        # player's cards\n        player = self.game_state.players[0]\n        obs.extend([player.hand[card] for card in ['7', '8', '9', '10', 'J', 'Q', 'K', 'A']])\n\n        # pile\n        obs.extend([self.game_state.pile[card] for card in ['7', '8', '9', '10', 'J', 'Q', 'K', 'A']])\n\n        # won cards\n        combined_won_cards = defaultdict(int)\n        for p in self.game_state.players:\n            for card, count in p.cards_won.items():\n                combined_won_cards[card] += count\n        obs.extend([combined_won_cards[card] for card in ['7', '8', '9', '10', 'J', 'Q', 'K', 'A']])\n\n        # points of both players\n        for p in self.game_state.players:\n            obs.append(p.points)\n\n        # first card in pile\n        first_card_index = self._card_to_index(self.game_state.first_card_played)\n        obs.append(first_card_index)\n\n        return np.array(obs, dtype=np.int32)\n\n    def _action_to_card(self, action):\n        card_map = ['7', '8', '9', '10', 'J', 'Q', 'K', 'A', 'END']\n        if action == 8:\n            return 'END'\n        return card_map[action]\n\n    def _card_to_index(self, card):\n        card_map = ['7', '8', '9', '10', 'J', 'Q', 'K', 'A']\n        if card is None:\n            return -1  # no card on table\n        return card_map.index(card)\n",
        "prediction": "",
        "file": "openai_gym_env.py"
    },
    {
        "id": 9,
        "prefix": "import numpy as np\nfrom collections import defaultdict\n\nclass Player:\n    def __init__(self, name):\n        self.name = name\n        self.hand = defaultdict(int)\n        self.cards_won = defaultdict(int)\n        self.points = 0\n\n    def draw_card(self, card):\n        self.hand[card] += 1\n\n    def play_card(self, card):\n        if self.hand[card] > 0:\n            self.hand[card] -= 1\n            return card\n\n\n    def need_cards(self):\n        return sum(self.hand.values()) < 4\n\n    def card_count(self):\n        return sum(self.hand.values())\n\n    def add_won_cards(self, cards):\n        for card, count in cards.items():\n            self.cards_won[card] += count\n            if card in ['10', 'A']:\n                self.points += 10 * count\n\n    def show_hand(self):\n        return {card: count for card, count in self.hand.items() if count > 0}\n\n    def show_won_cards(self):\n        return {card: count for card, count in self.cards_won.items() if count > 0}\n\n\nimport random\nfrom collections import defaultdict\nfrom player import Player\n\nclass CardGame:\n    def __init__(self, player_names):\n        self.players = [Player(name) for name in player_names]\n        self.deck = self.create_deck()\n        self.pile = defaultdict(int)\n        self.pile_winner_index = 0\n        self.first_player_index = 0\n        self.current_player_index = 0\n        self.first_card_played = None\n        self.deal_cards()\n\n    def create_deck(self):\n        cards = ['7', '8', '9', '10', 'J', 'Q', 'K', 'A']\n        deck = [card for card in cards for _ in range(4)]\n        random.shuffle(deck)\n        return deck\n\n    def deal_cards(self):\n      while any(player.need_cards() for player in self.players) and self.deck:\n          for player in self.players:\n              if player.need_cards() and self.deck:\n                  player.draw_card(self.deck.pop())\n\n    def reset(self):\n        self.deck = self.create_deck()\n        self.pile = defaultdict(int)\n        self.pile_winner_index = 0\n        self.first_card_played = None\n        self.first_player_index = 0\n        self.current_player_index = 0\n        for player in self.players:\n            player.hand = defaultdict(int)\n            player.cards_won = defaultdict(int)\n            player.points = 0\n        self.deal_cards()\n\n    def step(self, card):\n      needs_to_play_again = False\n      info = {\n        'invalid_move': False,\n        'reason': ''\n    }\n      if card == 'END':",
        "middle": "",
        "suffix": "          if self.current_player_index != self.first_player_index:\n              reward = -1000\n              done = True\n              info['invalid_move'] = True\n              info['reason'] = 'Played END but not played first'\n              return reward, done, needs_to_play_again, info\n          elif self.first_card_played is None:\n              reward = -1000\n              done = True\n              info['invalid_move'] = True\n              info['reason'] = 'Played END on first turn'\n              return reward, done, needs_to_play_again, info\n          else:\n              reward, done, needs_to_play_again = self._end_round()\n              reward += 5\n              self.current_player_index = self.pile_winner_index\n              return reward, done, needs_to_play_again, info\n\n\n      if (self.current_player_index == self.first_player_index) and self.first_card_played is not None:\n          if card != self.first_card_played and card != '7':\n              reward = -1000\n              done = True\n              info['invalid_move'] = True\n              info['reason'] = 'Tried to continue round with invalid card'\n              return reward, done, needs_to_play_again, info\n\n      if self.players[self.current_player_index].hand[card] <= 0:\n          reward = -1000\n          done = True\n          info['invalid_move'] = True\n          info['reason'] = 'Card not available in hand'\n          return reward, done, needs_to_play_again, info\n\n      self.players[self.current_player_index].play_card(card)\n      self.pile[card] += 1\n\n      if self.first_card_played is None:\n          self.first_card_played = card\n          self.pile_winner_index = self.current_player_index\n          self.first_player_index = self.current_player_index\n      else:\n          if card == self.first_card_played or card == '7':\n              self.pile_winner_index = self.current_player_index\n\n\n      if not needs_to_play_again:\n        self._next_turn()\n\n      reward = 5\n      done = self._check_game_over()\n      return reward, done, needs_to_play_again, info\n\n    def _next_turn(self):\n        self.current_player_index = (self.current_player_index + 1) % 2\n\n    def _end_round(self):\n        self.players[self.pile_winner_index].add_won_cards(self.pile)\n        reward = (self.pile['10'] + self.pile['A']) * 10 + 5\n\n        self.pile = defaultdict(int)\n        self.first_card_played = None\n\n        needs_to_play_again = False\n        if self.first_player_index == self.pile_winner_index:\n          needs_to_play_again = True\n\n        self.first_player_index = self.pile_winner_index\n        done = self._check_game_over()\n        if not done:\n          self.deal_cards()\n\n        return reward, done, needs_to_play_again\n\n    def play_opponent_move(self):\n        opponent = self.players[self.current_player_index]\n        valid_cards = []\n\n        if (self.current_player_index == self.first_player_index) and self.first_card_played is not None:\n            valid_cards = [card for card, count in opponent.hand.items() if count > 0 and (card == '7' or card == self.first_card_played)]\n            valid_cards.append('END')\n        else:\n            valid_cards = [card for card in opponent.hand if opponent.hand[card] > 0]\n\n        choice = random.choice(valid_cards)\n\n        _, done, needs_again, _ = self.step(choice)\n        return done, needs_again\n\n\n    def winner_reward(self):\n      bonus = 0\n      if self._check_game_over():\n        if self.players[0].points > self.players[1].points:\n          bonus = 50\n        if self.players[0].points < self.players[1].points:\n          bonus = -30\n\n      return bonus\n\n\n\n    def _check_game_over(self):\n        if len(self.deck) == 0 and all(player.card_count() == 0 for player in self.players):\n            return True\n        return False\n\n\nimport gym\nfrom gym import spaces\nfrom collections import defaultdict\nimport random\nfrom game import CardGame\n\nclass PlayerEnv(gym.Env):\n    def __init__(self, game_state):\n        super(PlayerEnv, self).__init__()\n        self.game_state = game_state\n        self.action_space = spaces.Discrete(9)  # 8 different cards and one 'END' action\n        self.observation_space = spaces.Box(low=0, high=52, shape=(8 + 8 + 8 + 2 + 1,), dtype=int)  # player's hand, pile on the table, won cards, points, first card in pile\n\n    def reset(self):\n        self.game_state.reset()\n        return self._get_obs()\n\n    def step(self, action):\n        card = self._action_to_card(action)\n        reward, done, needs_to_play_again, info = self.game_state.step(card)\n        if not done and not needs_to_play_again:\n            done, needs_again_opponent = self.game_state.play_opponent_move()\n            if not done and needs_again_opponent:\n                done, _ = self.game_state.play_opponent_move()\n\n        if done:\n            reward += self.game_state.winner_reward()\n\n        return self._get_obs(), reward, done, info\n\n    def render(self, mode='human'):\n        print(f\"\\n{'='*20} GAME STATE {'='*20}\")\n\n        for i, player in enumerate(self.game_state.players):\n            print(f\"Player {i+1} ({player.name}):\")\n            print(f\"  Hand: {player.show_hand()}\")\n            print(f\"  Won Cards: {player.show_won_cards()}\")\n            print(f\"  Points: {player.points}\")\n            print('-' * 50)\n\n        print(f\"Pile: {dict(self.game_state.pile)}\")\n        print(f\"First Card Played: {self.game_state.first_card_played}\")\n        print('='*50)\n\n    def close(self):\n        pass\n\n    def _get_obs(self):\n        obs = []\n\n        # player's cards\n        player = self.game_state.players[0]\n        obs.extend([player.hand[card] for card in ['7', '8', '9', '10', 'J', 'Q', 'K', 'A']])\n\n        # pile\n        obs.extend([self.game_state.pile[card] for card in ['7', '8', '9', '10', 'J', 'Q', 'K', 'A']])\n\n        # won cards\n        combined_won_cards = defaultdict(int)\n        for p in self.game_state.players:\n            for card, count in p.cards_won.items():\n                combined_won_cards[card] += count\n        obs.extend([combined_won_cards[card] for card in ['7', '8', '9', '10', 'J', 'Q', 'K', 'A']])\n\n        # points of both players\n        for p in self.game_state.players:\n            obs.append(p.points)\n\n        # first card in pile\n        first_card_index = self._card_to_index(self.game_state.first_card_played)\n        obs.append(first_card_index)\n\n        return np.array(obs, dtype=np.int32)\n\n    def _action_to_card(self, action):\n        card_map = ['7', '8', '9', '10', 'J', 'Q', 'K', 'A', 'END']\n        if action == 8:\n            return 'END'\n        return card_map[action]\n\n    def _card_to_index(self, card):\n        card_map = ['7', '8', '9', '10', 'J', 'Q', 'K', 'A']\n        if card is None:\n            return -1  # no card on table\n        return card_map.index(card)\n",
        "prediction": "",
        "file": "openai_gym_env.py"
    },
    {
        "id": 10,
        "prefix": "import numpy as np\nfrom collections import defaultdict\n\nclass Player:\n    def __init__(self, name):\n        self.name = name\n        self.hand = defaultdict(int)\n        self.cards_won = defaultdict(int)\n        self.points = 0\n\n    def draw_card(self, card):\n        self.hand[card] += 1\n\n    def play_card(self, card):\n        if self.hand[card] > 0:\n            self.hand[card] -= 1\n            return card\n\n\n    def need_cards(self):\n        return sum(self.hand.values()) < 4\n\n    def card_count(self):\n        return sum(self.hand.values())\n\n    def add_won_cards(self, cards):\n        for card, count in cards.items():\n            self.cards_won[card] += count\n            if card in ['10', 'A']:\n                self.points += 10 * count\n\n    def show_hand(self):\n        return {card: count for card, count in self.hand.items() if count > 0}\n\n    def show_won_cards(self):\n        return {card: count for card, count in self.cards_won.items() if count > 0}\n\n\nimport random\nfrom collections import defaultdict\nfrom player import Player\n\nclass CardGame:\n    def __init__(self, player_names):\n        self.players = [Player(name) for name in player_names]\n        self.deck = self.create_deck()\n        self.pile = defaultdict(int)\n        self.pile_winner_index = 0\n        self.first_player_index = 0\n        self.current_player_index = 0\n        self.first_card_played = None\n        self.deal_cards()\n\n    def create_deck(self):\n        cards = ['7', '8', '9', '10', 'J', 'Q', 'K', 'A']\n        deck = [card for card in cards for _ in range(4)]\n        random.shuffle(deck)\n        return deck\n\n    def deal_cards(self):\n      while any(player.need_cards() for player in self.players) and self.deck:\n          for player in self.players:\n              if player.need_cards() and self.deck:\n                  player.draw_card(self.deck.pop())\n\n    def reset(self):\n        self.deck = self.create_deck()\n        self.pile = defaultdict(int)\n        self.pile_winner_index = 0\n        self.first_card_played = None\n        self.first_player_index = 0\n        self.current_player_index = 0\n        for player in self.players:\n            player.hand = defaultdict(int)\n            player.cards_won = defaultdict(int)\n            player.points = 0\n        self.deal_cards()\n\n    def step(self, card):\n      needs_to_play_again = False\n      info = {\n        'invalid_move': False,\n        'reason': ''\n    }\n      if card == 'END':\n          if self.current_player_index != self.first_player_index:\n              reward = -1000\n              done = True\n              info['invalid_move'] = True\n              info['reason'] = 'Played END but not played first'\n              return reward, done, needs_to_play_again, info\n          elif self.first_card_played is None:\n              reward = -1000\n              done = True\n              info['invalid_move'] = True\n              info['reason'] = 'Played END on first turn'\n              return reward, done, needs_to_play_again, info\n          else:\n              reward, done, needs_to_play_again = self._end_round()\n              reward += 5\n              self.current_player_index = self.pile_winner_index\n              return reward, done, needs_to_play_again, info\n\n\n      if (self.current_player_index == self.first_player_index) and self.first_card_played is not None:\n          if card != self.first_card_played and card != '7':\n              reward = -1000\n              done = True\n              info['invalid_move'] = True\n              info['reason'] = 'Tried to continue round with invalid card'\n              return reward, done, needs_to_play_again, info\n\n      if self.players[self.current_player_index].hand[card] <= 0:\n          reward = -1000\n          done = True\n          info['invalid_move'] = True\n          info['reason'] = 'Card not available in hand'\n          return reward, done, needs_to_play_again, info\n\n      self.players[self.current_player_index].play_card(card)\n      self.pile[card] += 1\n\n      if self.first_card_played is None:\n          self.first_card_played = card\n          self.pile_winner_index = self.current_player_index\n          self.first_player_index = self.current_player_index\n      else:\n          if card == self.first_card_played or card == '7':\n              self.pile_winner_index = self.current_player_index\n\n\n      if not needs_to_play_again:\n        self._next_turn()\n\n      reward = 5\n      done = self._check_game_over()\n      return reward, done, needs_to_play_again, info\n\n    def _next_turn(self):\n        self.current_player_index = (self.current_player_index + 1) % 2\n\n    def _end_round(self):\n        self.players[self.pile_winner_index].add_won_cards(self.pile)\n        reward = (self.pile['10'] + self.pile['A']) * 10 + 5\n\n        self.pile = defaultdict(int)\n        self.first_card_played = None\n\n        needs_to_play_again = False\n        if self.first_player_index == self.pile_winner_index:\n          needs_to_play_again = True\n\n        self.first_player_index = self.pile_winner_index\n        done = self._check_game_over()\n        if not done:\n          self.deal_cards()\n\n        return reward, done, needs_to_play_again\n\n    def play_opponent_move(self):\n        opponent = self.players[self.current_player_index]\n        valid_cards = []\n\n        if (self.current_player_index == self.first_player_index) and self.first_card_played is not None:\n            valid_cards = [card for card, ",
        "middle": "count in opponent.hand.items() if count > 0 and (card == '7' or card == self.first_card_played)]",
        "suffix": "            valid_cards.append('END')\n        else:\n            valid_cards = [card for card in opponent.hand if opponent.hand[card] > 0]\n\n        choice = random.choice(valid_cards)\n\n        _, done, needs_again, _ = self.step(choice)\n        return done, needs_again\n\n\n    def winner_reward(self):\n      bonus = 0\n      if self._check_game_over():\n        if self.players[0].points > self.players[1].points:\n          bonus = 50\n        if self.players[0].points < self.players[1].points:\n          bonus = -30\n\n      return bonus\n\n\n\n    def _check_game_over(self):\n        if len(self.deck) == 0 and all(player.card_count() == 0 for player in self.players):\n            return True\n        return False\n\n\nimport gym\nfrom gym import spaces\nfrom collections import defaultdict\nimport random\nfrom game import CardGame\n\nclass PlayerEnv(gym.Env):\n    def __init__(self, game_state):\n        super(PlayerEnv, self).__init__()\n        self.game_state = game_state\n        self.action_space = spaces.Discrete(9)  # 8 different cards and one 'END' action\n        self.observation_space = spaces.Box(low=0, high=52, shape=(8 + 8 + 8 + 2 + 1,), dtype=int)  # player's hand, pile on the table, won cards, points, first card in pile\n\n    def reset(self):\n        self.game_state.reset()\n        return self._get_obs()\n\n    def step(self, action):\n        card = self._action_to_card(action)\n        reward, done, needs_to_play_again, info = self.game_state.step(card)\n        if not done and not needs_to_play_again:\n            done, needs_again_opponent = self.game_state.play_opponent_move()\n            if not done and needs_again_opponent:\n                done, _ = self.game_state.play_opponent_move()\n\n        if done:\n            reward += self.game_state.winner_reward()\n\n        return self._get_obs(), reward, done, info\n\n    def render(self, mode='human'):\n        print(f\"\\n{'='*20} GAME STATE {'='*20}\")\n\n        for i, player in enumerate(self.game_state.players):\n            print(f\"Player {i+1} ({player.name}):\")\n            print(f\"  Hand: {player.show_hand()}\")\n            print(f\"  Won Cards: {player.show_won_cards()}\")\n            print(f\"  Points: {player.points}\")\n            print('-' * 50)\n\n        print(f\"Pile: {dict(self.game_state.pile)}\")\n        print(f\"First Card Played: {self.game_state.first_card_played}\")\n        print('='*50)\n\n    def close(self):\n        pass\n\n    def _get_obs(self):\n        obs = []\n\n        # player's cards\n        player = self.game_state.players[0]\n        obs.extend([player.hand[card] for card in ['7', '8', '9', '10', 'J', 'Q', 'K', 'A']])\n\n        # pile\n        obs.extend([self.game_state.pile[card] for card in ['7', '8', '9', '10', 'J', 'Q', 'K', 'A']])\n\n        # won cards\n        combined_won_cards = defaultdict(int)\n        for p in self.game_state.players:\n            for card, count in p.cards_won.items():\n                combined_won_cards[card] += count\n        obs.extend([combined_won_cards[card] for card in ['7', '8', '9', '10', 'J', 'Q', 'K', 'A']])\n\n        # points of both players\n        for p in self.game_state.players:\n            obs.append(p.points)\n\n        # first card in pile\n        first_card_index = self._card_to_index(self.game_state.first_card_played)\n        obs.append(first_card_index)\n\n        return np.array(obs, dtype=np.int32)\n\n    def _action_to_card(self, action):\n        card_map = ['7', '8', '9', '10', 'J', 'Q', 'K', 'A', 'END']\n        if action == 8:\n            return 'END'\n        return card_map[action]\n\n    def _card_to_index(self, card):\n        card_map = ['7', '8', '9', '10', 'J', 'Q', 'K', 'A']\n        if card is None:\n            return -1  # no card on table\n        return card_map.index(card)\n",
        "prediction": "",
        "file": "openai_gym_env.py"
    },
    {
        "id": 11,
        "prefix": "import tkinter as tk\nfrom PIL import ImageGrab\nfrom utils import process_region, process_image, get_completion, load_api_key\nfrom openai import OpenAI\n\nclass QuizBotApp:\n    def __init__(self, root",
        "middle": "):",
        "suffix": "        self.root = root\n        self.start_x, self.start_y, self.temp_region, self.current_selection = 0, 0, None, 0\n        self.regions = {i: None for i in range(1, 6)}\n        self.client = OpenAI()\n        self.client.api_key = load_api_key()\n        self.setup_ui()\n\n    def on_button_press(self, event):\n        self.start_x, self.start_y = self.root.winfo_pointerx(), self.root.winfo_pointery()\n\n    def on_drag(self, event):\n        end_x, end_y = self.root.winfo_pointerx(), self.root.winfo_pointery()\n        self.temp_region = (self.start_x, self.start_y, end_x, end_y)\n\n    def on_button_release(self, event):\n        self.regions[self.current_selection] = self.temp_region\n        self.close_selection_window()\n        self.display_text(\"Region set.\\n\")\n\n    def close_selection_window(self):\n        self.selection_window.quit()\n        self.selection_window.destroy()\n\n    def select_window(self, selection_number):\n        self.current_selection = selection_number\n        selection_type = \"Question\" if selection_number == 1 else f\"Option {selection_number-1}\"\n        self.display_text(f\"Selecting {selection_type}...\\nPlease select the region on the screen.\\n\")\n        self.create_selection_window()\n\n    def create_selection_window(self):\n        self.selection_window = tk.Toplevel(self.root)\n        self.selection_window.attributes(\"-alpha\", 0.3)\n        self.selection_window.attributes(\"-fullscreen\", True)\n        self.selection_window.bind(\"<ButtonPress-1>\", self.on_button_press)\n        self.selection_window.bind(\"<B1-Motion>\", self.on_drag)\n        self.selection_window.bind(\"<ButtonRelease-1>\", self.on_button_release)\n        self.selection_window.mainloop()\n\n    def display_text(self, text):\n        self.text_display.delete(\"1.0\", tk.END)\n        self.text_display.insert(tk.END, text)\n\n    def take_screenshots(self):\n        ocr_results = []\n        for region in self.regions.values():\n            if region:\n                try:\n                    x1, y1, x2, y2 = process_region(region)\n                    screenshot = ImageGrab.grab(bbox=(x1, y1, x2, y2))\n                    ocr_results.append(process_image(screenshot))\n                except Exception as e:\n                    self.display_text(f\"Error taking screenshot: {e}\\n\")\n                    return\n        prompt = \"Question: \" + \"\\n\" + \"\\n\".join(ocr_results) + \"\\nOnly write correct asnwer.\"\n        answer = get_completion(prompt, self.client)\n        self.display_text(answer)\n\n    def setup_ui(self):\n        self.setup_question_button()\n        self.setup_option_buttons()\n        self.setup_screenshot_button()\n        self.setup_text_display()\n\n    def setup_question_button(self):\n        question_button = tk.Button(self.root, text=\"Question\", command=lambda: self.select_window(1))\n        question_button.grid(row=0, column=0, columnspan=2)\n    \n    def setup_option_buttons(self):\n        for i in range(2, 6):\n            button_text = f\"Option {i-1}\"\n            row = 1 if i < 4 else 2\n            column = 0 if i % 2 == 0 else 1\n            select_button = tk.Button(self.root, text=button_text, command=lambda i=i: self.select_window(i))\n            select_button.grid(row=row, column=column, padx=5)\n    \n    def setup_screenshot_button(self):\n        screenshot_button = tk.Button(self.root, text=\"Show answer\", command=self.take_screenshots)\n        screenshot_button.grid(row=3, column=0, columnspan=2)\n    \n    def setup_text_display(self):\n        self.text_display = tk.Text(self.root, height=10, width=50)\n        self.text_display.grid(row=4, column=0, columnspan=2)\n\n\nimport pytesseract\nfrom PIL import Image\nimport openai\nimport os\n\ndef process_region(region):\n    x1 = min(region[0], region[2])\n    y1 = min(region[1], region[3])\n    x2 = max(region[0], region[2])\n    y2 = max(region[1], region[3])\n    return x1, y1, x2, y2\n\ndef process_image(image):\n    try:\n        gray_image = image.convert('L')\n        text = pytesseract.image_to_string(gray_image, lang='eng')\n        return text\n    except Exception as e:\n        print(f\"Error in OCR processing: {e}\")\n        return \"\"\n\ndef get_completion(prompt, client):\n    try:\n        response = client.chat.completions.create(\n            model=\"gpt-3.5-turbo\",\n            messages=[{\"role\": \"user\", \"content\": prompt}]\n        )\n        return response.choices[0].message.content.strip()\n    except Exception as e:\n        print(f\"Error communicating with OpenAI: {e}\")\n        return \"\"\n\ndef load_api_key():\n    return os.getenv(\"OPENAI_API_KEY\", \"default_api_key_here\")\n\n\nimport tkinter as tk\ndef main():\n    root = tk.Tk()\n    app = QuizBotApp(root)\n    root.mainloop()\n\nif __name__ == \"__main__\":\n    main()\n",
        "prediction": "",
        "file": "quizbot.py"
    },
    {
        "id": 12,
        "prefix": "import tkinter as tk\nfrom PIL import ImageGrab\nfrom utils import process_region, process_image, get_completion, load_api_key\nfrom openai import OpenAI\n\nclass QuizBotApp:\n    def __init__(self, root):\n        self.root = root\n        self.start_x, self.start_y, self.temp_region, self.current_selection = 0, 0, None, 0\n        self.regions = {i: None for i in range(1, 6)}\n        self.client = OpenAI()\n        self.client.api_key = load_api_key()\n        self.setup_ui()\n\n    def on_button_press(self, event):\n        self.start_x, self.start_y = self.root.winfo_pointerx(), self.root.winfo_pointery()\n\n    def on_drag(self, event):\n        end_x, end_y = self.root.winfo_pointerx(), self.root.winfo_pointery()\n        self.temp_region = (self.start_x, self.start_y, end_x, end_y)\n\n    def on_button_release(self, event):\n        self.regions[self.current_selection] = self.temp_region\n        self.close_selection_window()\n        self.display_text(\"Region set.\\n\")\n\n    def close_selection_window(self):\n        self.selection_window.quit()\n        self.selection_window.destroy()\n\n    def select_window(self, selection_number):\n        self.current_selection = selection_number\n        selection_type = \"Question\" if selection_number == 1 else f\"Option {selection_number-1}\"\n        self.display_text(f\"Selecting {selection_type}...\\nPlease select the region on the screen.\\n\")\n        self.create_selection_window()\n\n    def create_selection_window(self):\n        self.selection_window = tk.Toplevel(self.root)\n        self.selection_window.attributes(\"-alpha\", 0.3)\n        self.selection_window.attributes(\"-fullscreen\", True)\n        self.selection_window.bind(\"<ButtonPress-1>\", self.on_button_press)\n        self.selection_window.bind(\"<B1-Motion>\", self.on_drag)\n        self.selection_window.bind(\"<ButtonRelease-1>\", self.on_button_release)\n        self.selection_window.mainloop()\n\n    def display_text(self, text):\n        self.text_display.delete(\"1.0\", tk.END)\n        self.text_display.insert(tk.END, text)\n\n    def take_screenshots(self):\n        ocr_results = []\n        for region in self.regions.values():\n            if region:\n                try:\n                    x1, y1, x2, y2 = process_region(region)\n                    screenshot = ImageGrab.grab(bbox=(x1, y1, x2, y2))\n                    ocr_results.append(process_image(screenshot))\n                except Exception as e:\n                    self.display_text(f\"Error taking screenshot: {e}\\n\")\n                    return\n        prompt = \"Question: \" + \"\\n\" + \"\\n\".join(ocr_results) + \"\\nOnly write correct asnwer.\"\n        answer = get_completion(prompt, self.client)\n        self.display_text(answer)\n\n    def setup_ui(self):\n        self.setup_question_button()\n        self.setup_option_buttons()\n        self.setup_screenshot_button()\n        self.setup_text_display()\n\n    def setup_question_button(self):\n        question_button = tk.Button(self.root, text=\"Question\", command=lambda: self.select_window(1))\n        question_button.grid(r",
        "middle": "ow=0, column=0, columnspan=2)",
        "suffix": "    \n    def setup_option_buttons(self):\n        for i in range(2, 6):\n            button_text = f\"Option {i-1}\"\n            row = 1 if i < 4 else 2\n            column = 0 if i % 2 == 0 else 1\n            select_button = tk.Button(self.root, text=button_text, command=lambda i=i: self.select_window(i))\n            select_button.grid(row=row, column=column, padx=5)\n    \n    def setup_screenshot_button(self):\n        screenshot_button = tk.Button(self.root, text=\"Show answer\", command=self.take_screenshots)\n        screenshot_button.grid(row=3, column=0, columnspan=2)\n    \n    def setup_text_display(self):\n        self.text_display = tk.Text(self.root, height=10, width=50)\n        self.text_display.grid(row=4, column=0, columnspan=2)\n\n\nimport pytesseract\nfrom PIL import Image\nimport openai\nimport os\n\ndef process_region(region):\n    x1 = min(region[0], region[2])\n    y1 = min(region[1], region[3])\n    x2 = max(region[0], region[2])\n    y2 = max(region[1], region[3])\n    return x1, y1, x2, y2\n\ndef process_image(image):\n    try:\n        gray_image = image.convert('L')\n        text = pytesseract.image_to_string(gray_image, lang='eng')\n        return text\n    except Exception as e:\n        print(f\"Error in OCR processing: {e}\")\n        return \"\"\n\ndef get_completion(prompt, client):\n    try:\n        response = client.chat.completions.create(\n            model=\"gpt-3.5-turbo\",\n            messages=[{\"role\": \"user\", \"content\": prompt}]\n        )\n        return response.choices[0].message.content.strip()\n    except Exception as e:\n        print(f\"Error communicating with OpenAI: {e}\")\n        return \"\"\n\ndef load_api_key():\n    return os.getenv(\"OPENAI_API_KEY\", \"default_api_key_here\")\n\n\nimport tkinter as tk\ndef main():\n    root = tk.Tk()\n    app = QuizBotApp(root)\n    root.mainloop()\n\nif __name__ == \"__main__\":\n    main()\n",
        "prediction": "",
        "file": "quizbot.py"
    },
    {
        "id": 13,
        "prefix": "import tkinter as tk\nfrom PIL import ImageGrab\nfrom utils import process_region, process_image, get_completion, load_api_key\nfrom openai import OpenAI\n\nclass QuizBotApp:\n    def __init__(self, root):\n        self.root = root\n        self.start_x, self.start_y, self.temp_region, self.current_selection = 0, 0, None, 0\n        self.regions = {i: None for i in range(1, 6)}\n        self.client = OpenAI()\n        self.client.api_key = load_api_key()\n        self.setup_ui()\n\n    def on_button_press(self, event):\n        self.start_x, self.start_y = self.root.winfo_pointerx(), self.root.winfo_pointery()\n\n    def on_drag(self, event):\n        end_x, end_y = self.root.winfo_pointerx(), self.root.winfo_pointery()\n        self.temp_region = (self.start_x, self.start_y, end_x, end_y)\n\n    def on_button_release(self, event):\n        self.regions[self.current_selection] = self.temp_region\n        self.close_selection_window()\n        self.display_text(\"Region set.\\n\")\n\n    def close_selection_window(self):\n        self.selection_window.quit()\n        self.selection_window.destroy()\n\n    def select_window(self, selection_number):\n        self.current_selection = selection_number\n        selection_type = \"Question\" if selection_number == 1 else f\"Option {selection_number-1}\"\n        self.display_text(f\"Selecting {selection_type}...\\nPlease select the region on the screen.\\n\")\n        self.create_selection_window()\n\n    def create_selection_window(self):\n        self.selection_window = tk.Toplevel(self.root)\n        self.selection_window.attributes(\"-alpha\", 0.3)\n        self.selection_window.attributes(\"-fullscreen\", True)\n        self.selection_window.bind(\"<ButtonPress-1>\", self.on_button_press)\n        self.selection_window.bind(\"<B1-Motion>\", self.on_drag)\n        self.selection_window.bind(\"<ButtonRelease-1>\", self.on_button_release)\n        self.selection_window.mainloop()\n",
        "middle": "",
        "suffix": "    def display_text(self, text):\n        self.text_display.delete(\"1.0\", tk.END)\n        self.text_display.insert(tk.END, text)\n\n    def take_screenshots(self):\n        ocr_results = []\n        for region in self.regions.values():\n            if region:\n                try:\n                    x1, y1, x2, y2 = process_region(region)\n                    screenshot = ImageGrab.grab(bbox=(x1, y1, x2, y2))\n                    ocr_results.append(process_image(screenshot))\n                except Exception as e:\n                    self.display_text(f\"Error taking screenshot: {e}\\n\")\n                    return\n        prompt = \"Question: \" + \"\\n\" + \"\\n\".join(ocr_results) + \"\\nOnly write correct asnwer.\"\n        answer = get_completion(prompt, self.client)\n        self.display_text(answer)\n\n    def setup_ui(self):\n        self.setup_question_button()\n        self.setup_option_buttons()\n        self.setup_screenshot_button()\n        self.setup_text_display()\n\n    def setup_question_button(self):\n        question_button = tk.Button(self.root, text=\"Question\", command=lambda: self.select_window(1))\n        question_button.grid(row=0, column=0, columnspan=2)\n    \n    def setup_option_buttons(self):\n        for i in range(2, 6):\n            button_text = f\"Option {i-1}\"\n            row = 1 if i < 4 else 2\n            column = 0 if i % 2 == 0 else 1\n            select_button = tk.Button(self.root, text=button_text, command=lambda i=i: self.select_window(i))\n            select_button.grid(row=row, column=column, padx=5)\n    \n    def setup_screenshot_button(self):\n        screenshot_button = tk.Button(self.root, text=\"Show answer\", command=self.take_screenshots)\n        screenshot_button.grid(row=3, column=0, columnspan=2)\n    \n    def setup_text_display(self):\n        self.text_display = tk.Text(self.root, height=10, width=50)\n        self.text_display.grid(row=4, column=0, columnspan=2)\n\n\nimport pytesseract\nfrom PIL import Image\nimport openai\nimport os\n\ndef process_region(region):\n    x1 = min(region[0], region[2])\n    y1 = min(region[1], region[3])\n    x2 = max(region[0], region[2])\n    y2 = max(region[1], region[3])\n    return x1, y1, x2, y2\n\ndef process_image(image):\n    try:\n        gray_image = image.convert('L')\n        text = pytesseract.image_to_string(gray_image, lang='eng')\n        return text\n    except Exception as e:\n        print(f\"Error in OCR processing: {e}\")\n        return \"\"\n\ndef get_completion(prompt, client):\n    try:\n        response = client.chat.completions.create(\n            model=\"gpt-3.5-turbo\",\n            messages=[{\"role\": \"user\", \"content\": prompt}]\n        )\n        return response.choices[0].message.content.strip()\n    except Exception as e:\n        print(f\"Error communicating with OpenAI: {e}\")\n        return \"\"\n\ndef load_api_key():\n    return os.getenv(\"OPENAI_API_KEY\", \"default_api_key_here\")\n\n\nimport tkinter as tk\ndef main():\n    root = tk.Tk()\n    app = QuizBotApp(root)\n    root.mainloop()\n\nif __name__ == \"__main__\":\n    main()\n",
        "prediction": "",
        "file": "quizbot.py"
    },
    {
        "id": 14,
        "prefix": "import tkinter as tk\nfrom PIL import ImageGrab\nfrom utils import process_region, process_image, get_completion, load_api_key\nfrom openai import OpenAI\n\nclass QuizBotApp:\n    def __init__(self, root):\n        self.root = root\n        self.start_x, self.start_y, self.temp_region, self.current_selection = 0, 0, None, 0\n        self.regions = {i: None for i in range(1, 6)}\n        self.client = OpenAI()\n        self.client.api_key = load_api_key()\n        self.setup_ui()\n\n    def on_button_press(self, event):\n        self.start_x, self.start_y = self.root.winfo_pointerx(), self.root.winfo_pointery()\n\n    def on_drag(self, event):\n        end_x, end_y = self.root.winfo_pointerx(), self.root.winfo_pointery()\n        self.temp_region = (self.start_x, self.start_y, end_x, end_y)\n\n    def on_button_release(self, event):\n        self.regions[self.current_selection] = self.temp_region\n        self.close_selection_window()\n        self.display_text(\"Region set.\\n\")\n\n    def close_selection_window(self):\n        self.selection_window.quit()\n        self.selection_window.destroy()\n\n    def select_window(self, selection_number):\n        self.current_selection = selection_number\n        selection_type = \"Question\" if selection_number == 1 else f\"Option {selection_number-1}\"\n        self.display_text(f\"Selecting {selection_type}...\\nPlease select the region on the screen.\\n\")\n        self.create_selection_window()\n\n    def create_selection_window(self):\n        self.selection_window = tk.Toplevel(self.root)\n        self.selection_window.attributes(\"-alpha\", 0.3)\n        self.selection_window.attributes(\"-fullscreen\", True)\n        self.selection_window.bind(\"<ButtonPress-1>\", self.on_button_press)\n        self.selection_window.bind(\"<B1-Motion>\", self.on_drag)\n        self.selection_window.bind(\"<ButtonRelease-1>\", self.on_button_release)\n        self.selection_window.mainloop()\n\n    def display_text(self, text):\n        self.text_display.delete(\"1.0\", tk.END)\n        self.text_display.insert(tk.END, text)\n\n    def take_screenshots(self):\n        ocr_results = []\n        for region in self.regions.values():\n            if region:\n                try:\n                    x1, y1, x2, y2 = process_region(region)\n                    screenshot = ImageGrab.grab(bbox=(x1, y1, x2, y2))\n                    ocr_results.append(process_image(screenshot))\n                except Exception as e:\n                    self.display_text(f\"Error taking screenshot: {e}\\n\")\n                    return\n        prompt = \"Question: \" + \"\\n\" + \"\\n\".join(ocr_results) + \"\\nOnly write correct asnwer.\"\n        answer = get_completion(prompt, self.client)\n        self.display_text(answer)\n\n    def setup_ui(self):\n        self.setup_question_button()\n        self.setup_option_buttons()\n        self.setup_screenshot_button()\n        self.setup_text_display()\n\n    def setup_question_button(self):\n        question_button = tk.Button(self.root, text=\"Question\", command=lambda: self.select_window(1))\n        question_button.grid(row=0, column=0, columnspan=2)\n    \n    def setup_option_buttons(self):\n        for i in range(2, 6):\n            button_text = f\"Option {i-1}\"\n            row = 1 if i < 4 else 2\n            column = 0 if i % 2 == 0 else 1\n            select_button = tk.Button(self.root, text=button_text, command=lambda i=i: self.select_window(i))\n            select_button.grid(row=row, column=column, padx=5)\n    \n    def setup_screenshot_button(self):\n        screenshot_button = tk.Button(self.root, text=\"Show answer\", command=self.take_screenshots)\n        screenshot_button.grid(row=3, column=0, columnspan=2)\n    \n    def setup_text_display(self):\n        self.text_display = tk.Text(self.root, height=10, width=50)\n        self.text_display.grid(row=4, column=0, columnspan=2)\n\n\nimport pytesseract\nfrom PIL import Image\nimport openai\nimport os\n\ndef process_region(region):\n    x1 = min(region[0], region[2])\n    y1 = min(region[1], region[3])\n    x2 = max(region[0], region[2])\n    y2 = max(region[1], region[3])\n    return x1, y1, x2, y2\n\ndef process_image(image):\n    try:\n        gray_image = image.convert('L')\n        text = pytesseract.image_to_string(gray_image, lang='eng')\n        return text\n    except Exception as e:\n        print(f\"Error in OCR processing: {e}\")\n        return \"\"\n\ndef get_completion(prompt, client):\n    try:\n        response = client.chat.completions.create(\n            model=\"gpt-3.5-turbo\",\n            messages=[{\"role\": \"user\", \"content\": prompt}]\n        )\n ",
        "middle": "       return response.choices[0].message.content.strip()",
        "suffix": "    except Exception as e:\n        print(f\"Error communicating with OpenAI: {e}\")\n        return \"\"\n\ndef load_api_key():\n    return os.getenv(\"OPENAI_API_KEY\", \"default_api_key_here\")\n\n\nimport tkinter as tk\ndef main():\n    root = tk.Tk()\n    app = QuizBotApp(root)\n    root.mainloop()\n\nif __name__ == \"__main__\":\n    main()\n",
        "prediction": "",
        "file": "quizbot.py"
    },
    {
        "id": 15,
        "prefix": "import tkinter as tk\nfrom PIL import ImageGrab\nfrom utils import process_region, process_image, get_completion, load_api_key\nfrom openai import OpenAI\n\nclass QuizBotApp:\n    def __init__(self, root):\n        self.root = root\n        self.start_x, self.start_y, self.temp_region, self.current_selection = 0, 0, None, 0\n        self.regions = {i: None for i in range(1, 6)}\n        self.client = OpenAI()\n        self.client.api_key = load_api_key()\n        self.setup_ui()\n\n    def on_button_press(self, event):\n        self.start_x, self.start_y = self.root.winfo_pointerx(), self.root.winfo_pointery()\n\n    def on_drag(self, event):\n        end_x, end_y = self.root.winfo_pointerx(), self.root.winfo_pointery()\n        self.temp_region = (self.start_x, self.start_y, end_x, end_y)\n\n    def on_button_release(self, event):\n        self.regions[self.current_selection] = self.temp_region\n        self.close_selection_window()\n        self.display_text(\"Region set.\\n\")\n\n    def close_selection_window(self):\n        self.selection_window.quit()\n        self.selection_window.destroy()\n\n    def select_window(self, selection_number):\n        self.current_selection = selection_number\n        selection_type = \"Question\" if selection_number == 1 else f\"Option {selection_number-1}\"\n        self.display_text(f\"Selecting {selection_type}...\\nPlease select the region on the screen.\\n\")\n        self.create_selection_window()\n\n    def create_selection_window(self):\n        self.selection_window = tk.Toplevel(self.root)\n        self.selection_window.attributes(\"-alpha\", 0.3)\n        self.selection_window.attributes(\"-fullscreen\", True)\n        self.selection_window.bind(\"<ButtonPress-1>\", self.on_button_press)\n        self.selection_window.bind(\"<B1-Motion>\", self.on_drag)\n        self.selection_window.bind(\"<ButtonRelease-1>\", self.on_button_release)\n        self.selection_window.mainloop()\n\n    def display_text(self, text):\n        self.text_display.delete(\"1.0\", tk.END)\n        self.text_display.insert(tk.END, text)\n\n    def take_screenshots(self):\n        ocr_results = []\n        for region in self.regions.values():\n            if region:\n                try:\n                    x1, y1, x2, y2 = process_region(region)\n                    screenshot = ImageGrab.grab(bbox=(x1, y1, x2, y2))\n                    ocr_results.append(process_image(screenshot))\n                except Exception as e:\n                    self.display_text(f\"Error taking screenshot: {e}\\n\")\n                    return\n        prompt = \"Question: \" + \"\\n\" + \"\\n\".join(ocr_results) + \"\\nOnly write correct asnwer.\"\n        answer = get_completion(prompt, self.client)\n        self.display_text(answer)\n\n    def setup_ui(self):\n        self.setup_question_button()\n        self.setup_option_buttons()\n        self.setup_screenshot_button()\n        self.setup_text_display()\n\n    def setup_question_button(self):\n        question_button = tk.Button(self.root, text=\"Question\", command=lambda: self.select_window(1))\n        question_button.grid(row=0, column=0, columnspan=2)\n    \n    def setup_option_buttons(self):\n        for i in range(2, 6):\n            button_text = f\"Option {i-1}\"\n            row = 1 if i < 4 else 2\n            column = 0 if i % 2 == 0 else 1\n            select_button = tk.Button(self.root, text=button_text, command=lambda i=i: self.select_window(i))\n            select_button.grid(row=row, column=column, padx=5)\n    \n    def setup_screenshot_button(self):\n        screenshot_button = tk.Button(self.root, text=\"Show answer\", command=self.take_screenshots)\n        screenshot_button.grid(row=3, column=0, columnspan=2)\n    \n    def setup_text_display(self):\n        self.text_display = tk.Text(self.root, height=10, width=50)\n        self.text_display.grid(row=4, column=",
        "middle": "0, columnspan=2)",
        "suffix": "\n\nimport pytesseract\nfrom PIL import Image\nimport openai\nimport os\n\ndef process_region(region):\n    x1 = min(region[0], region[2])\n    y1 = min(region[1], region[3])\n    x2 = max(region[0], region[2])\n    y2 = max(region[1], region[3])\n    return x1, y1, x2, y2\n\ndef process_image(image):\n    try:\n        gray_image = image.convert('L')\n        text = pytesseract.image_to_string(gray_image, lang='eng')\n        return text\n    except Exception as e:\n        print(f\"Error in OCR processing: {e}\")\n        return \"\"\n\ndef get_completion(prompt, client):\n    try:\n        response = client.chat.completions.create(\n            model=\"gpt-3.5-turbo\",\n            messages=[{\"role\": \"user\", \"content\": prompt}]\n        )\n        return response.choices[0].message.content.strip()\n    except Exception as e:\n        print(f\"Error communicating with OpenAI: {e}\")\n        return \"\"\n\ndef load_api_key():\n    return os.getenv(\"OPENAI_API_KEY\", \"default_api_key_here\")\n\n\nimport tkinter as tk\ndef main():\n    root = tk.Tk()\n    app = QuizBotApp(root)\n    root.mainloop()\n\nif __name__ == \"__main__\":\n    main()\n",
        "prediction": "",
        "file": "quizbot.py"
    },
    {
        "id": 16,
        "prefix": "import numpy as np\nimport cv2\nimport sys\nimport pandas as pd\n\ndef process_single_image(image_path):\n    # Učitaj sliku i konvertuj u RGB\n    img = cv2.imread(image_path)\n    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n    \n    # Izdvoj ROI (Region of Interest)\n    img = img[250:800, 200:800]\n    \n    # Konverzija u grayscale\n    img_gray = cv2.cvtCol",
        "middle": "or(img, cv2.COLOR_RGB2GRAY)",
        "suffix": "    \n    # Binarizacija slike\n    img_bin = cv2.adaptiveThreshold(img_gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 61, 31)\n    img_bin = cv2.bitwise_not(img_bin)\n    \n    # Priprema kernela za morfološke operacije\n    kernel_ero = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3, 3))\n    kernel_open = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5))\n    \n    img_ero = cv2.erode(img_bin, kernel_ero, iterations=2)\n    img_open = cv2.dilate(img_ero, kernel_open, iterations=12)\n    img_ero = cv2.erode(img_open, kernel_ero, iterations=26)\n    \n    # Pronalaženje kontura\n    contours, hierarchy = cv2.findContours(img_ero, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)\n    \n    # Filtriranje kontura na osnovu definisanih uslova\n    duck_contours = []\n    for contour in contours:\n        (x, y), radius = cv2.minEnclosingCircle(contour)\n        \n        is_in_corner = (x < 100 and y > 300) or (x > 500 and y > 500) or (x < 200 and y > 500) or (y < 50 and x > 500) or (x < 100 and y < 100)\n        is_grass = (350 < x < 400) and (y > 480)\n        is_on_edge = x > 580 or y < 20\n\n        if 14 < radius < 75 and not is_in_corner and not is_on_edge and not is_grass:\n            duck_contours.append(contour)\n\n    return len(duck_contours)\n\ndef main(folder_path):\n    csv_path = folder_path + 'duck_count.csv'\n    duck_data = pd.read_csv(csv_path)\n    \n    absolute_errors = []\n\n\n    for index, row in duck_data.iterrows():\n        image_name = row['picture']\n        true_ducks = row['ducks']\n        \n\n        image_path = folder_path + image_name\n        predicted_ducks = process_single_image(image_path)\n        \n\n        absolute_error = abs(true_ducks - predicted_ducks)\n        absolute_errors.append(absolute_error)\n    \n\n    mae = sum(absolute_errors) / len(absolute_errors)\n    print(mae)\n\n\nif __name__ == \"__main__\":\n    folder_path = sys.argv[1]\n    main(folder_path)",
        "prediction": "",
        "file": "simple_cv.py"
    },
    {
        "id": 17,
        "prefix": "import numpy as np\nimport cv2\nimport sys\nimport pandas as pd\n\ndef process_single_image(image_path):\n    # Učitaj sliku i konvertuj u RGB\n    img = cv2.imread(image_path)\n    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n",
        "middle": "    ",
        "suffix": "    # Izdvoj ROI (Region of Interest)\n    img = img[250:800, 200:800]\n    \n    # Konverzija u grayscale\n    img_gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)\n    \n    # Binarizacija slike\n    img_bin = cv2.adaptiveThreshold(img_gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 61, 31)\n    img_bin = cv2.bitwise_not(img_bin)\n    \n    # Priprema kernela za morfološke operacije\n    kernel_ero = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3, 3))\n    kernel_open = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5))\n    \n    img_ero = cv2.erode(img_bin, kernel_ero, iterations=2)\n    img_open = cv2.dilate(img_ero, kernel_open, iterations=12)\n    img_ero = cv2.erode(img_open, kernel_ero, iterations=26)\n    \n    # Pronalaženje kontura\n    contours, hierarchy = cv2.findContours(img_ero, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)\n    \n    # Filtriranje kontura na osnovu definisanih uslova\n    duck_contours = []\n    for contour in contours:\n        (x, y), radius = cv2.minEnclosingCircle(contour)\n        \n        is_in_corner = (x < 100 and y > 300) or (x > 500 and y > 500) or (x < 200 and y > 500) or (y < 50 and x > 500) or (x < 100 and y < 100)\n        is_grass = (350 < x < 400) and (y > 480)\n        is_on_edge = x > 580 or y < 20\n\n        if 14 < radius < 75 and not is_in_corner and not is_on_edge and not is_grass:\n            duck_contours.append(contour)\n\n    return len(duck_contours)\n\ndef main(folder_path):\n    csv_path = folder_path + 'duck_count.csv'\n    duck_data = pd.read_csv(csv_path)\n    \n    absolute_errors = []\n\n\n    for index, row in duck_data.iterrows():\n        image_name = row['picture']\n        true_ducks = row['ducks']\n        \n\n        image_path = folder_path + image_name\n        predicted_ducks = process_single_image(image_path)\n        \n\n        absolute_error = abs(true_ducks - predicted_ducks)\n        absolute_errors.append(absolute_error)\n    \n\n    mae = sum(absolute_errors) / len(absolute_errors)\n    print(mae)\n\n\nif __name__ == \"__main__\":\n    folder_path = sys.argv[1]\n    main(folder_path)",
        "prediction": "",
        "file": "simple_cv.py"
    },
    {
        "id": 18,
        "prefix": "import numpy as np\nimport cv2\nimport sys\nimport pandas as pd\n\ndef process_single_image(image_path):\n    # Učitaj sliku i konvertuj u RGB\n    img = cv2.imread(image_path)\n    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n    \n    # Izdvoj ROI (Region of Interest)\n    img = img[250:800, 200:800]\n    \n    # Konverzija u grayscale\n    img_gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)\n    \n    # Binarizacija slike\n    img_bin = cv2.adaptiveThreshold(img_gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 61, 31)\n    img_bin = cv2.bitwise_not(img_bin)\n    \n    # Priprema kernela za morfološke operacije\n    kernel_ero = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3, 3))\n    kernel_open = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5))\n    \n    img_ero = cv2.erode(img_bin, kernel_ero, iterations=2)\n    img_open = cv2.dilate(img_ero, kernel_open, iterations=12)\n    img_ero = cv2.erode(img_open, kernel_ero, iterations=26)\n    \n    # Pronalaženje kontura\n    contours, hierarchy = cv2.findContours(img_ero, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)\n    \n    # Filtriranje kontura na osnovu definisanih uslova\n    duck_contours = []\n    for contour in contours:\n        (x, y), radius = cv2.minEnclosingCircle(contour)\n        \n        is_in_corner = (x < 100 and y > 300) or (x > 500 and y > 500) or (x < 200 and y > 500) or (y < 50 and x > 500) or (x < 100 and y < 100)\n        is_grass = (350 < x < 400) and (y > 480)\n        is_on_edge = x > 580 or y < 20\n\n        if 14 < radius < 75 and not is_in_corner and not is_on_edge and not is_grass:\n            duck_contours.append(contour)\n\n    return len(duck_contours)\n\ndef main(folder_path):\n    csv_path = folder_path + 'duck_count.csv'\n",
        "middle": "    duck_data = pd.read_csv(csv_path)",
        "suffix": "    \n    absolute_errors = []\n\n\n    for index, row in duck_data.iterrows():\n        image_name = row['picture']\n        true_ducks = row['ducks']\n        \n\n        image_path = folder_path + image_name\n        predicted_ducks = process_single_image(image_path)\n        \n\n        absolute_error = abs(true_ducks - predicted_ducks)\n        absolute_errors.append(absolute_error)\n    \n\n    mae = sum(absolute_errors) / len(absolute_errors)\n    print(mae)\n\n\nif __name__ == \"__main__\":\n    folder_path = sys.argv[1]\n    main(folder_path)",
        "prediction": "",
        "file": "simple_cv.py"
    },
    {
        "id": 19,
        "prefix": "import numpy as np\nimport cv2\nimport sys\nimport pandas as pd\n\ndef process_single_image(image_path):\n    # Učitaj sliku i konvertuj u RGB\n    img = cv2.imread(image_path)\n    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n    \n    # Izdvoj ROI (Region of Interest)\n    img = img[250:800, 200:800]\n    \n    # Konverzija u grayscale\n    img_gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)\n    \n    # Binarizacija slike\n    img_bin = cv2.adaptiveThreshold(img_gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 61, 31)\n    img_bin = cv2.bitwise_not(img_bin)\n    \n    # Priprema kernela za morfološke operacije\n    kernel_ero = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3, 3))\n    kernel_open = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5))\n    \n    img_ero = cv2.erode(img_bin, kernel_ero, iterations=2)\n    img_open = cv2.dilate(img_ero, kernel_open, iterations=12)\n    img_ero = cv2.erode(img_open, kernel_ero, iterations=26)\n    \n    # Pronalaženje kontura\n    contours, hierarchy = cv2.findContours(img_ero, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)\n    \n    # Filtriranje kontura na osnovu definisanih uslova\n    duck_contours = []\n    for contour in contours:\n        (x, y), radius = cv2.minEnclosingCircle(contour)\n        \n        is_in_corner = (x < 100 and y > 300) or (x > 500 and y > 500) or (x < 200 and y > 500) or (y < 50 and x > 500) or (x < 100 and y < 100)\n        ",
        "middle": "is_grass = (350 < x < 400) and (y > 480)",
        "suffix": "        is_on_edge = x > 580 or y < 20\n\n        if 14 < radius < 75 and not is_in_corner and not is_on_edge and not is_grass:\n            duck_contours.append(contour)\n\n    return len(duck_contours)\n\ndef main(folder_path):\n    csv_path = folder_path + 'duck_count.csv'\n    duck_data = pd.read_csv(csv_path)\n    \n    absolute_errors = []\n\n\n    for index, row in duck_data.iterrows():\n        image_name = row['picture']\n        true_ducks = row['ducks']\n        \n\n        image_path = folder_path + image_name\n        predicted_ducks = process_single_image(image_path)\n        \n\n        absolute_error = abs(true_ducks - predicted_ducks)\n        absolute_errors.append(absolute_error)\n    \n\n    mae = sum(absolute_errors) / len(absolute_errors)\n    print(mae)\n\n\nif __name__ == \"__main__\":\n    folder_path = sys.argv[1]\n    main(folder_path)",
        "prediction": "",
        "file": "simple_cv.py"
    },
    {
        "id": 20,
        "prefix": "import numpy as np\nimport cv2\nimport sys\nimport pandas as pd\n\ndef process_single_image(image_path):\n    # Učitaj sliku i konvertuj u RGB\n    img = cv2.imread(image_path)\n    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n    \n    # Izdvoj ROI (Region of Interest)\n    img = img[250:800, 200:800]\n    \n    # Konverzija u grayscale\n    img_gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)\n    \n    # Binarizacija slike\n    img_bin = cv2.adaptiveThreshold(img_gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 61, 31)\n    img_bin = cv2.bitwise_not(img_bin)\n    \n    # Priprema kernela za morfološke operacije\n    kernel_ero = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3, 3))\n    kernel_open = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5))\n    \n    img_ero = cv2.erode(img_bin, kernel_ero, iterations=2)\n    img_open = cv2.dilate(img_ero, kernel_open, iterations=12)\n    img_ero = cv2.erode(img_open, kernel_ero, iterations=26)\n    \n    # Pronalaženje kontura\n    contours, hierarchy = cv2.findContours(img_ero, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)\n    \n    # Filtriranje kontura na osnovu definisanih uslova\n    duck_contours = []\n    for contour in contours:\n        (x, y), radius = cv2.minEnclosingCircle(contour)\n        \n        is_in_corner = (x < 100 and y > 300) or (x > 500 and y > 500) or (x < 200 and y > 500) or (y < 50 and x > 500) or (x < 100 and y < 100)\n        is_grass = (350 < x < 400) and (y > 480)\n        is_on_edge = x > 580 or y < 20\n\n        if 14 < radius < 75 and not is_in_corner and not is_on_edge and not is_grass:\n            duck_contours.append(contour)\n\n    return len(duck_contours)\n\ndef main(folder_path):\n    csv_path = folder_path + 'duck_count.csv'\n    duck_data = pd.read_csv(csv_path)\n    \n    absolute_errors = []\n\n\n    for ",
        "middle": "index, row in duck_data.iterrows():",
        "suffix": "        image_name = row['picture']\n        true_ducks = row['ducks']\n        \n\n        image_path = folder_path + image_name\n        predicted_ducks = process_single_image(image_path)\n        \n\n        absolute_error = abs(true_ducks - predicted_ducks)\n        absolute_errors.append(absolute_error)\n    \n\n    mae = sum(absolute_errors) / len(absolute_errors)\n    print(mae)\n\n\nif __name__ == \"__main__\":\n    folder_path = sys.argv[1]\n    main(folder_path)",
        "prediction": "",
        "file": "simple_cv.py"
    },
    {
        "id": 21,
        "prefix": "import pandas as pd\nfrom sklearn import preprocessing\nfrom sklearn.model_selection import train_test_split\nfrom datasets import Dataset\nfrom transformers import AutoTokenizer\nimport tensorflow as tf\n\n\n\nfile_path = '/content/drive/MyDrive/notebooks/fakenews.csv'\ndf = pd.read_csv(file_path)\ndf = df[['text', 'label']]\ndf = df.dropna()\n\n\nlabel_encoder = preprocessing.LabelEncoder()\ndf['label'] = label_encoder.fit_transform(df['label'].tolist())\n\ntrain_df, test_df = train_test_split(df, train_size=0.7, shuffle=True, random_state=0)\nval_df, test_df = train_test_split(test_df, train_size=0.5, shuffle=True, random_state=0)\n\n\n\n\ntokenizer = AutoTokenizer.from_pretrained(\"huawei-noah/TinyBERT_General_4L_312D\")\n\n\ntrain_dataset = Dataset.from_pandas(train_df)\nval_dataset = Dataset.from_pandas(val_df)\ntest_dataset = Dataset.from_pandas(test_df)\n\ndef tokenize_data(examples):\n    return tokenizer(examples[\"text\"], truncation=True, padding='max_length', max_length=512)\n\ntokenized_train = train_dataset.map(tokenize_data, batched=True)\ntokenized_val = val_dataset.map(tokenize_data, batched=True)",
        "middle": "",
        "suffix": "tokenized_test = test_dataset.map(tokenize_data, batched=True)\n\n\nfrom transformers import AutoModelForSequenceClassification, Trainer, TrainingArguments, DataCollatorWithPadding\n\nmodel = AutoModelForSequenceClassification.from_pretrained(\"huawei-noah/TinyBERT_General_4L_312D\", num_labels=2)\n\n\ndata_collator = DataCollatorWithPadding(tokenizer=tokenizer)\n\n\ntraining_args = TrainingArguments(\n    output_dir=\"/content/drive/MyDrive/results/tinybert\",\n    learning_rate=2e-5,\n    per_device_train_batch_size=8,\n    per_device_eval_batch_size=8,\n    num_train_epochs=5,\n    weight_decay=0.01,\n    evaluation_strategy=\"epoch\",\n    logging_strategy=\"epoch\"\n)\n\n\ntrainer = Trainer(\n    model=model,\n    args=training_args,\n    train_dataset=tokenized_train,\n    eval_dataset=tokenized_val,\n    tokenizer=tokenizer,\n    data_collator=data_collator,\n)\n\ntrainer.train()\n\ntrainer.save_model('/content/drive/MyDrive/tinybert')\n\n\nfrom sklearn.metrics import classification_report\nimport numpy as np\n\npredictions = trainer.predict(tokenized_test)\npreds = np.argmax(predictions.predictions, axis=1)\n\nlabels = tokenized_test['label']\n\nprint(\"Validation Classification Report:\")\nprint(classification_report(labels, preds, target_names=[\"Class 0\", \"Class 1\"]))",
        "prediction": "",
        "file": "tinybert.py"
    },
    {
        "id": 22,
        "prefix": "import pandas as pd\nfrom sklearn import preprocessing\nfrom sklearn.model_selection import train_test_split\nfrom datasets import Dataset\nfrom transformers import AutoTokenizer\nimport tensorflow as tf\n\n\n\nfile_path = '/content/drive/MyDrive/notebooks/fakenews.csv'\ndf = pd.read_csv(file_path)\ndf = df[['text', 'label']]\ndf = df.dropna()\n\n\nlabel_encoder = preprocessing.LabelEncoder()\ndf['label'] = label_encoder.fit_transform(df['label'].tolist())\n\ntrain_df, test_df = train_test_split(df, train_size=0.7, shuffle=True, random_state=0)\nval_df, test_df = train_test_split(test_df, tra",
        "middle": "in_size=0.5, shuffle=True, random_state=0)",
        "suffix": "\n\n\n\ntokenizer = AutoTokenizer.from_pretrained(\"huawei-noah/TinyBERT_General_4L_312D\")\n\n\ntrain_dataset = Dataset.from_pandas(train_df)\nval_dataset = Dataset.from_pandas(val_df)\ntest_dataset = Dataset.from_pandas(test_df)\n\ndef tokenize_data(examples):\n    return tokenizer(examples[\"text\"], truncation=True, padding='max_length', max_length=512)\n\ntokenized_train = train_dataset.map(tokenize_data, batched=True)\ntokenized_val = val_dataset.map(tokenize_data, batched=True)\ntokenized_test = test_dataset.map(tokenize_data, batched=True)\n\n\nfrom transformers import AutoModelForSequenceClassification, Trainer, TrainingArguments, DataCollatorWithPadding\n\nmodel = AutoModelForSequenceClassification.from_pretrained(\"huawei-noah/TinyBERT_General_4L_312D\", num_labels=2)\n\n\ndata_collator = DataCollatorWithPadding(tokenizer=tokenizer)\n\n\ntraining_args = TrainingArguments(\n    output_dir=\"/content/drive/MyDrive/results/tinybert\",\n    learning_rate=2e-5,\n    per_device_train_batch_size=8,\n    per_device_eval_batch_size=8,\n    num_train_epochs=5,\n    weight_decay=0.01,\n    evaluation_strategy=\"epoch\",\n    logging_strategy=\"epoch\"\n)\n\n\ntrainer = Trainer(\n    model=model,\n    args=training_args,\n    train_dataset=tokenized_train,\n    eval_dataset=tokenized_val,\n    tokenizer=tokenizer,\n    data_collator=data_collator,\n)\n\ntrainer.train()\n\ntrainer.save_model('/content/drive/MyDrive/tinybert')\n\n\nfrom sklearn.metrics import classification_report\nimport numpy as np\n\npredictions = trainer.predict(tokenized_test)\npreds = np.argmax(predictions.predictions, axis=1)\n\nlabels = tokenized_test['label']\n\nprint(\"Validation Classification Report:\")\nprint(classification_report(labels, preds, target_names=[\"Class 0\", \"Class 1\"]))",
        "prediction": "",
        "file": "tinybert.py"
    },
    {
        "id": 23,
        "prefix": "import pandas as pd\nfrom sklearn import preprocessing\nfrom sklearn.model_selection import train_test_split\nfrom datasets import Dataset\nfrom transformers import AutoTokenizer\nimport tensorflow as tf\n\n\n\nfile_path = '/content/drive/MyDrive/notebooks/fakenews.csv'\ndf = pd.read_csv(file_path)\ndf = df[['text', 'label']]\ndf = df.dropna()\n\n\nlabel_encoder = preprocessing.LabelEncoder()\ndf['label'] = label_encoder.fit_transform(df['label'].tolist())\n\ntrain_df, test_df = train_test_split(df, train_size=0.7, shuffle=True, random_state=0)\nval_df, test_df = train_test_split(test_df, train_size=0.5, shuffle=True, random_state=0)\n\n\n\n\ntokenizer = AutoTokenizer.from_pretrained(\"huawei-noah/TinyBERT_General_4L_312D\")\n\n\ntrain_dataset = Dataset.from_pandas(train_df)\nval_dataset = Dataset.from_pandas(val_df)\ntest_dataset = Dataset.from_pandas(test_df)\n\ndef tokenize_data(examples):\n    return tokenizer(examples[\"text\"], truncation=True, padding='max_length', max_length=512)\n\ntokenized_train = train_dataset.map(tokenize_data, batched=True)\ntokenized_val = val_dataset.map(tokenize_data, batched=True)\ntokenized_test = test_dataset.map(tokenize_data, batched=True)\n\n\nfrom transformers import AutoModelForSequenceClassification, Trainer, TrainingArguments, DataCollatorWithPadding\n\nmodel = AutoModelForSequenceClassification.from_pretrained(\"huawei-noah/TinyBERT_General_4L_312D\", num_labels=2)\n\n\ndata_collator = DataCollatorWithPadding(tokenizer=tokenizer)\n\n\ntraining_args = TrainingArguments(\n    output_dir=\"/content/drive/MyDrive/results/tinybert\",\n    learning_rate=2e-5,\n    per_device_train_batch_size=8,\n    per_device_eval_batch_size=8,\n    num_train_epochs=5,\n    weight_decay=0.01,\n    evaluation_strategy=\"epoch\",\n    logging_strategy=\"epoch\"\n)\n\n\ntrainer = Trainer(\n    model=model,\n    args=training_args,\n    train_dataset=tokenized_train,\n    eval_dataset=tokenized_val,\n    tokenizer=tokenizer,\n    data_collator=data_collator,\n)\n\ntrainer.train()\n\ntrainer.save_model('/content/drive/MyDrive/tinybert')\n\n\nfrom sklearn.metrics import classification_report\nimport numpy as np\n\npredictions = trainer.predict(tokenized_test)\npreds = np.argmax(predictions.predictions, axis=1)\n\nlabels = tokenized_test['label']\n\nprint(\"Validation Classification Report:\")\nprint(classification_report(labels, preds, target_names=[\"Class 0",
        "middle": "\", \"Class 1\"])",
        "suffix": "import pandas as pd\nfrom sklearn import preprocessing\nfrom sklearn.model_selection import train_test_split\nfrom datasets import Dataset\nfrom transformers import AutoTokenizer\nimport tensorflow as tf\n\n\n\nfile_path = '/content/drive/MyDrive/notebooks/fakenews.csv'\ndf = pd.read_csv(file_path)\ndf = df[['text', 'label']]\ndf = df.dropna()\n\n\nlabel_encoder = preprocessing.LabelEncoder()\ndf['label'] = label_encoder.fit_transform(df['label'].tolist())\n\ntrain_df, test_df = train_test_split(df, train_size=0.7, shuffle=True, random_state=0)\nval_df, test_df = train_test_split(test_df, train_size=0.5, shuffle=True, random_state=0)\n\n\n\n\ntokenizer = AutoTokenizer.from_pretrained(\"huawei-noah/TinyBERT_General_4L_312D\")\n\n\ntrain_dataset = Dataset.from_pandas(train_df)\nval_dataset = Dataset.from_pandas(val_df)\ntest_dataset = Dataset.from_pandas(test_df)\n\ndef tokenize_data(examples):\n    return tokenizer(examples[\"text\"], truncation=True, padding='max_length', max_length=512)\n\ntokenized_train = train_dataset.map(tokenize_data, batched=True)\ntokenized_val = val_dataset.map(tokenize_data, batched=True)\ntokenized_test = test_dataset.map(tokenize_data, batched=True)\n\n\nfrom transformers import AutoModelForSequenceClassification, Trainer, TrainingArguments, DataCollatorWithPadding\n\nmodel = AutoModelForSequenceClassification.from_pretrained(\"huawei-noah/TinyBERT_General_4L_312D\", num_labels=2)\n\n\ndata_collator = DataCollatorWithPadding(tokenizer=tokenizer)\n\n\ntraining_args = TrainingArguments(\n    output_dir=\"/content/drive/MyDrive/results/tinybert\",\n    learning_rate=2e-5,\n    per_device_train_batch_size=8,\n    per_device_eval_batch_size=8,\n    num_train_epochs=5,\n    weight_decay=0.01,\n    evaluation_strategy=\"epoch\",\n    logging_strategy=\"epoch\"\n)\n\n\ntrainer = Trainer(\n    model=model,\n    args=training_args,\n    train_dataset=tokenized_train,\n    eval_dataset=tokenized_val,\n    tokenizer=tokenizer,\n    data_collator=data_collator,\n)\n\ntrainer.train()\n\ntrainer.save_model('/content/drive/MyDrive/tinybert')\n\n\nfrom sklearn.metrics import classification_report\nimport numpy as np\n\npredictions = trainer.predict(tokenized_test)\npreds = np.argmax(predictions.predictions, axis=1)\n\nlabels = tokenized_test['label']\n\nprint(\"Validation Classification Report:\")\nprint(classification_report(labels, preds, target_names=[\"Class 0\", \"Class 1\"]))",
        "prediction": "",
        "file": "tinybert.py"
    },
    {
        "id": 24,
        "prefix": "import pandas as pd\nfrom sklearn import preprocessing\nfrom sklearn.model_selection import train_test_split\nfrom datasets import Dataset\nfrom transformers import AutoTokenizer\nimport tensorflow as tf\n\n\n\nfile_path = '/content/drive/MyDrive/notebooks/fakenews.csv'\ndf = pd.read_csv(file_path)\ndf = df[['text', 'label']]\ndf = df.dropna()\n\n\nlabel_encoder = preprocessing.LabelEncoder()\ndf['label'] = label_encoder.fit_transform(df['label'].tolist())\n\ntrain_df, test_df = train_test_split(df, train_size=0.7, shuffle=True, random_state=0)\nval_df, test_df = train_test_split(test_df, train_size=0.5, shuffle=True, random_state=0)\n\n\n\n\ntokenizer = AutoTokenizer.from_pretrained(\"huawei-noah/TinyBERT_General_4L_312D\")\n\n\ntrain_dataset = Dataset.from_pandas(train_df)\nval_dataset = Dataset.from_pandas(val_df)\ntest_dataset = Dataset.from_pandas(test_df)\n\ndef tokenize_data(examples):\n    return tokenizer(examples[\"text\"], truncation=True, padding='max_length', max_length=512)\n\ntokenized_train = train_dataset.map(tokenize_data, batched=True)\ntokenized_val = val_dataset.map(tokenize_data, batched=True)\ntokenized_test = test_dataset.map(tokenize_data, batched=True)\n\n\nfrom transformers import AutoModelForSequenceClassification, Trainer, TrainingArguments, DataCollatorWithPadding\n\nmodel = AutoModelForSequenceClassification.from_pretrained(\"huawei-noah/TinyBERT_General_4L_312D\", num_labels=2)\n\n\ndata_collator = DataCollatorWithPadding(token",
        "middle": "izer=tokenizer)",
        "suffix": "\n\ntraining_args = TrainingArguments(\n    output_dir=\"/content/drive/MyDrive/results/tinybert\",\n    learning_rate=2e-5,\n    per_device_train_batch_size=8,\n    per_device_eval_batch_size=8,\n    num_train_epochs=5,\n    weight_decay=0.01,\n    evaluation_strategy=\"epoch\",\n    logging_strategy=\"epoch\"\n)\n\n\ntrainer = Trainer(\n    model=model,\n    args=training_args,\n    train_dataset=tokenized_train,\n    eval_dataset=tokenized_val,\n    tokenizer=tokenizer,\n    data_collator=data_collator,\n)\n\ntrainer.train()\n\ntrainer.save_model('/content/drive/MyDrive/tinybert')\n\n\nfrom sklearn.metrics import classification_report\nimport numpy as np\n\npredictions = trainer.predict(tokenized_test)\npreds = np.argmax(predictions.predictions, axis=1)\n\nlabels = tokenized_test['label']\n\nprint(\"Validation Classification Report:\")\nprint(classification_report(labels, preds, target_names=[\"Class 0\", \"Class 1\"]))",
        "prediction": "",
        "file": "tinybert.py"
    },
    {
        "id": 25,
        "prefix": "import pandas as pd\nfrom sklearn import preprocessing\nfrom sklearn.model_selection import train_test_split\nfrom datasets import Dataset\nfrom transformers import AutoTokenizer\nimport tensorflow as tf\n\n\n\nfile_path = '/content/drive/MyDrive/notebooks/fakenews.csv'\ndf = pd.read_csv(file_path)\ndf = df[['text', 'label']]\ndf = df.dropna()\n\n\nlabel_encoder = preprocessing.LabelEncoder()\ndf['label'] = label_encoder.fit_transform(df['label'].tolist())\n\ntrain_df, test_df = train_test_split(df, train_size=0.7, shuffle=True, random_state=0)\nval_df, test_df = train_test_split(test_df, train_size=0.5, shuffle=True, random_state=0)\n\n\n\n\ntokenizer = AutoTokenizer.from_pretrained(\"huawei-noah/TinyBERT_General_4L_312D\")\n\n\ntrain_dataset = Dataset.from_pandas(train_df)\nval_dataset = Dataset.from_pandas(val_df)\ntest_dataset = Dataset.from_pandas(test_df)\n\ndef tokenize_data(examples):\n    return tokenizer(examples[\"text\"], truncation=True, padding='max_length', max_length=512)\n\ntokenized_train = train_dataset.map(tokenize_data, batched=True)\ntokenized_val = val_dataset.map(tokenize_data, batched=True)\ntokenized_test = test_dataset.map(token",
        "middle": "ize_data, batched=True)",
        "suffix": "\n\nfrom transformers import AutoModelForSequenceClassification, Trainer, TrainingArguments, DataCollatorWithPadding\n\nmodel = AutoModelForSequenceClassification.from_pretrained(\"huawei-noah/TinyBERT_General_4L_312D\", num_labels=2)\n\n\ndata_collator = DataCollatorWithPadding(tokenizer=tokenizer)\n\n\ntraining_args = TrainingArguments(\n    output_dir=\"/content/drive/MyDrive/results/tinybert\",\n    learning_rate=2e-5,\n    per_device_train_batch_size=8,\n    per_device_eval_batch_size=8,\n    num_train_epochs=5,\n    weight_decay=0.01,\n    evaluation_strategy=\"epoch\",\n    logging_strategy=\"epoch\"\n)\n\n\ntrainer = Trainer(\n    model=model,\n    args=training_args,\n    train_dataset=tokenized_train,\n    eval_dataset=tokenized_val,\n    tokenizer=tokenizer,\n    data_collator=data_collator,\n)\n\ntrainer.train()\n\ntrainer.save_model('/content/drive/MyDrive/tinybert')\n\n\nfrom sklearn.metrics import classification_report\nimport numpy as np\n\npredictions = trainer.predict(tokenized_test)\npreds = np.argmax(predictions.predictions, axis=1)\n\nlabels = tokenized_test['label']\n\nprint(\"Validation Classification Report:\")\nprint(classification_report(labels, preds, target_names=[\"Class 0\", \"Class 1\"]))",
        "prediction": "",
        "file": "tinybert.py"
    },
    {
        "id": 26,
        "prefix": "import matplotlib\nimport matplotlib.pyplot as plt\nimport plotly.express as px\nimport seaborn as sb\nimport pandas as pd\nimport numpy as np\nimport statsmodels.api as sm\nfrom sklearn.decomposition import PCA\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.ensemble import RandomForestClassifier, RandomForestRegressor\nfrom sklearn.neural_network import MLPClassifier, MLPRegressor\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.metrics import mean_absolute_error, r2_score, accuracy_score\nimport warnings\n\nwarnings.filterwarnings(\"ignore\")\n\ndef plot_correlation_for_col(df, col_name):\n    plt.figure(figsize=(12,6))\n    correlation_matrix = df.corr()\n    sorted_col_corr = correlation_matrix[col_name].sort_values(ascending=True)\n    sorted_col_corr = sorted_col_corr.drop(col_name)\n    sb.barplot(x=sorted_col_corr.index, y=sorted_col_corr.values, palette='RdBu')\n    plt.xticks(rotation=90)\n    plt.tight_layout()\n    plt.show()\n\ndef plot_explained_variance(pca_model):\n    plt.figure(figsize=(9,3))\n    explained_variance = pca_model.explained_variance_ratio_\n    cumulative_variance = explained_variance.cumsum()\n    plt.subplot(1, 2, 1)\n    plt.bar(range(1, len(explained_variance) + 1), explained_variance, alpha=0.8, align='center')\n    plt.xlabel('Glavna komponenta')\n    plt.ylabel('Objasnjena varijansa')\n    plt.su",
        "middle": "bplot(1, 2, 2)",
        "suffix": "    plt.plot(range(1, len(cumulative_variance) + 1), cumulative_variance, '--o')\n    plt.xlabel('Broj glavnih komponenti')\n    plt.ylabel('Kumulativna varijansa')\n    plt.tight_layout()\n    plt.show()\n\ndef plot_pc_loading(pca_model, pc_idx, columns, largest_n_pc=None):\n    plt.figure(figsize=(12,6))\n    pc_loadings_df = pd.DataFrame(data=pca_model.components_, columns=columns)\n    loading = pc_loadings_df.iloc[pc_idx]\n    sorted_loading_abs = loading.abs().sort_values(ascending=True)\n    largest_n_pc = 0 if largest_n_pc is None else largest_n_pc\n    sorted_loading = loading[sorted_loading_abs.index][-largest_n_pc:]\n    sb.barplot(x=sorted_loading.index, y=sorted_loading.values, palette='Reds')\n    plt.xticks(rotation=90)\n    plt.title(f'Correlation with {pc_idx}. component')\n    plt.tight_layout()\n    plt.show()\n\ndef visualize_principal_components(principal_components: np.ndarray, n_principal_components: int, \n                                   target_col: pd.Series = None, n_samples: int = None):\n    if n_samples is not None and n_samples < principal_components.shape[0]:\n        indices = np.random.choice(principal_components.shape[0], n_samples, replace=False)\n        principal_components = principal_components[indices, :]\n        if target_col is not None:\n            target_col = target_col.iloc[indices]\n    if n_principal_components == 2:\n        fig = px.scatter(x=principal_components[:, 0], y=principal_components[:, 1],\n                         opacity=0.6, color=target_col, color_continuous_scale='RdBu', width=700, height=600)\n        fig.update_traces(marker={'size': 10})\n        fig.update_layout(title='Principal components visualisations', xaxis_title=\"PC1\", yaxis_title=\"PC2\")\n        fig.show()\n    elif n_principal_components == 3:\n        fig = px.scatter_3d(x=principal_components[:, 0], y=principal_components[:, 1], z=principal_components[:, 2],\n                            opacity=0.6, color=target_col, color_continuous_scale='RdBu', width=1000)\n        fig.update_traces(marker={'size': 6})\n        fig.update_layout(title='Principal components visualisations', \n                          scene=dict(xaxis_title=\"PC1\", yaxis_title=\"PC2\", zaxis_title=\"PC3\",\n                                     xaxis_autorange='reversed', yaxis_autorange='reversed'))\n        fig.show()\n    else:\n        raise Exception('number of principal components must be 2 or 3')\n\ndef getPcaModel(df, n_components=2, random_state=42):\n    x = df.drop(columns=['league_rank', 'league_id'])\n    x_scaled = scale(x)\n    pca_model = PCA(n_components=n_components, random_state=random_state)\n    principal_components = pca_model.fit_transform(x_scaled)\n    return pca_model, principal_components\n\ndef getRandomForestClassifier(X_train, y_train):\n    model = RandomForestClassifier(n_estimators=300, random_state=42,\n                                   max_depth=10, bootstrap=True, min_samples_leaf=1,\n                                   min_samples_split=10)\n    model.fit(X_train, y_train)\n    return model\n\ndef getMLPClassifier(X_train, y_train):\n    model = MLPClassifier(hidden_layer_sizes=(50,50), activation='relu', solver='adam',\n                          max_iter=1000, learning_rate='constant', alpha=0.05,\n                          early_stopping=True, random_state=42)\n    model.fit(scale(X_train), y_train)\n    return model\n\ndef getMLPRegressorModel(X_train, y_train):\n    model = MLPRegressor(hidden_layer_sizes=(100, 50), max_iter=500, \n                         learning_rate_init=0.001, early_stopping=True, random_state=42)\n    model.fit(scale(X_train), y_train)\n    return model\n\ndef getRandomForestModel(X_train, y_train):\n    model = RandomForestRegressor(n_estimators=300, random_state=42,\n                                  max_depth=10, bootstrap=True, min_samples_leaf=4,\n                                  min_samples_split=2)\n    model.fit(X_train, y_train)\n    return model\n\ndef getLinearRegressionModel(X_train, y_train):\n    x_with_const = sm.add_constant(X_train)\n    model = sm.OLS(y_train, x_with_const).fit()\n    return model\n\ndef getFeatureImportancesPca(model):\n    feature_importances = model.feature_importances_\n    sorted_idx = np.argsort(feature_importances)[::-1]\n    plt.figure(figsize=(10, 6))\n    plt.title(\"PCA Component Importances\")\n    plt.bar(range(len(feature_importances)), feature_importances[sorted_idx], align=\"center\")\n    plt.xticks(range(len(feature_importances)), [f\"PC{i}\" for i in sorted_idx], rotation=90)\n    plt.xlim([-1, len(feature_importances)])\n    plt.show()\n\ndef getFeatureImportances(model, columns):\n    feature_importances = model.feature_importances_\n    sorted_idx = np.argsort(feature_importances)[::-1]\n    plt.figure(figsize=(10, 6))\n    plt.title(\"Feature Importances\")\n    plt.bar(range(len(columns)), feature_importances[sorted_idx], align=\"center\")\n    plt.xticks(range(len(columns)), [columns[i] for i in sorted_idx], rotation=90)\n    plt.xlim([-1, len(columns)])\n    plt.show()\n\ndef league_test_split(df, test_size=0.2, random_state=42):\n    leagues = df['league_id'].unique()\n    train_leagues, test_leagues = train_test_split(leagues, test_size=test_size, random_state=random_state)\n    X_train = df[df['league_id'].isin(train_leagues)].drop(['league_rank', 'league_id'], axis=1)\n    y_train = df[df['league_id'].isin(train_leagues)]['league_rank']\n    X_test = df[df['league_id'].isin(test_leagues)].drop(['league_rank', 'league_id'], axis=1)\n    y_test = df[df['league_id'].isin(test_leagues)]['league_rank']\n    return X_train, X_test, y_train, y_test\n\ndef scale(x):\n    scaler = StandardScaler(with_mean=True, with_std=True)\n    return scaler.fit_transform(x)\n\ndef evaluate_model_performance(model_name, y_true, predictions, num_attributes, print_accuracy=False):\n    print(f\"Model: {model_name}\")\n    if not print_accuracy:\n        mae = mean_absolute_error(y_true, predictions)\n        print(f\"Mean Absolute Error (MAE): {mae}\")\n        r2 = r2_score(y_true, predictions)\n        ar2 = get_rsquared_adj(r2, len(predictions), num_attributes)\n        print(f\"Adjusted R-squared: {r2}\")\n    else:\n        accuracy = accuracy_score(y_true, predictions)\n        print(f'Accuracy: {accuracy:.4f}')\n\ndef plot_predictions_distribution(model_name, y_true, predictions):\n    plt.hist(predictions, bins=len(set(y_true)), edgecolor='black')\n    plt.xlabel('League rank')\n    plt.ylabel('Number of predictions')\n    plt.title(f'Distribution {model_name}')\n    plt.show()\n\ndef get_rsquared_adj(r_squared, n, p):\n    adjusted_r_squared = 1 - (1 - r_squared) * (n - 1) / (n - p - 1)\n    return adjusted_r_squared\n\ndef load_data(filepath):\n    df = pd.read_csv(filepath)\n    return df\n\ndef preprocess_data(df, columns_to_normalize, columns_to_drop, groupby_column='league_id'):\n    for col in columns_to_normalize:\n        normalized_col_name = f'normalized_{col}'\n        if col in df.columns:\n            normalized_values = df.groupby(groupby_column)[col].transform(lambda x: (x - x.mean()) / x.std())\n            df[normalized_col_name] = normalized_values.fillna(0)\n    columns_to_drop = [col for col in columns_to_drop if col in df.columns]\n    df = df.drop(columns=columns_to_drop)\n    return df\n",
        "prediction": "",
        "file": "utils_models.py"
    },
    {
        "id": 27,
        "prefix": "import matplotlib\nimport matplotlib.pyplot as plt\nimport plotly.express as px\nimport seaborn as sb\nimport pandas as pd\nimport numpy as np\nimport statsmodels.api as sm\nfrom sklearn.decomposition import PCA\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.ensemble import RandomForestClassifier, RandomForestRegressor\nfrom sklearn.neural_network import MLPClassifier, MLPRegressor\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.metrics import mean_absolute_error, r2_score, accuracy_score\nimport warnings\n\nwarnings.filterwarnings(\"ignore\")\n\ndef plot_correlation_for_col(df, col_name):\n    plt.figure(figsize=(12,6))\n    correlation_matrix = df.corr()\n    sorted_col_corr = correlation_matrix[col_name].sort_values(ascending=True)\n    sorted_col_corr = sorted_col_corr.drop(col_name)\n    sb.barplot(x=sorted_col_corr.index, y=sorted_col_corr.values, palette='RdBu')\n    plt.xticks(rotation=90)\n    plt.tight_layout()\n    plt.show()\n\ndef plot_explained_variance(pca_model):\n    plt.figure(figsize=(9,3))\n    explained_variance = pca_model.explained_variance_ratio_\n    cumulative_variance = explained_variance.cumsum()\n    plt.subplot(1, 2, 1)\n    plt.bar(range(1, len(explained_variance) + 1), explained_variance, alpha=0.8, align='center')\n    plt.xlabel('Glavna komponenta')\n    plt.ylabel('Objasnjena varijansa')\n    plt.subplot(1, 2, 2)\n    plt.plot(range(1, len(cumulative_variance) + 1), cumulative_variance, '--o')\n    plt.xlabel('Broj glavnih komponenti')\n    plt.ylabel('Kumulativna varijansa')\n    plt.tight_layout()\n    plt.show()\n\ndef plot_pc_loading(pca_model, pc_idx, columns, largest_n_pc=None):\n    plt.figure(figsize=(12,6))\n    pc_loadings_df = pd.DataFrame(data=pca_model.components_, columns=columns)\n    loading = pc_loadings_df.iloc[pc_idx]\n    sorted_loading_abs = loading.abs().sort_values(ascending=True)\n    largest_n_pc = 0 if largest_n_pc is None else largest_n_pc\n    sorted_loading = loading[sorted_loading_abs.index][-largest_n_pc:]\n    sb.barplot(x=sorted_loading.index, y=sorted_loading.values, palette='Reds')\n    plt.xticks(rotation=90)\n    plt.title(f'Correlation with {pc_idx}. component')\n    plt.tight_layout()\n    plt.show()\n\ndef visualize_principal_components(principal_components: np.ndarray, n_principal_components: int, \n                                   target_col: pd.Series = None, n_samples: int = None):\n    if n_samples is not None and n_samples < principal_components.shape[0]:\n        indices = np.random.choice(principal_components.shape[0], n_samples, replace=False)\n        principal_components = principal_components[indices, :]\n        if target_col is not None:\n            target_col = target_col.iloc[indices]\n    if n_principal_components == 2:\n        fig = px.scatter(x=principal_components[:, 0], y=principal_components[:, 1],\n                         opacity=0.6, color=target_col, color_continuous_scale='RdBu', width=700, height=600)\n        fig.update_traces(marker={'size': 10})\n        fig.update_layout(title='Principal components visualisations', xaxis_title=\"PC1\", yaxis_title=\"PC2\")\n        fig.show()\n    elif n_principal_components == 3:\n        fig = px.scatter_3d(x=principal_components[:, 0], y=principal_components[:, 1], z=principal_components[:, 2],\n                            opacity=0.6, color=target_col, color_continuous_scale='RdBu', width=1000)\n        fig.update_traces(marker={'size': 6})\n        fig.update_layout(title='Principal components visualisations', \n                          scene=dict(xaxis_title=\"PC1\", yaxis_title=\"PC2\", zaxis_title=\"PC3\",\n                                     xaxis_autorange='reversed', yaxis_autorange='reversed'))\n        fig.show()\n    else:\n        raise Exception('number of principal components must be 2 or 3')\n\ndef getPcaModel(df, n_components=2, random_state=42):\n    x = df.drop(columns=['league_rank', 'league_id'])\n    x_scaled = scale(x)\n    pca_model = PCA(n_components=n_components, random_state=random_state)\n    principal_components = pca_model.fit_transform(x_scaled)\n    return pca_model, principal_components\n\ndef getRandomForestClassifier(X_train, y_train):\n    model = RandomForestClassifier(n_estimators=300, random_state=42,\n                                   max_depth=10, bootstrap=True, min_samples_leaf=1,\n                                   min_samples_split=10)\n    model.fit(X_train, y_train)\n    return model\n\ndef getMLPClassifier(X_train, y_train):\n    model = MLPClassifier(hidden_layer_sizes=(50,50), activation='relu', solver='adam',\n                          max_iter=1000, learning_rate='constant', alpha=0.05,\n                          early_stopping=True, random_state=42)\n    model.fit(scale(X_train), y_train)\n    return model\n\ndef getMLPRegressorModel(X_train, y_train):\n    model = MLPRegressor(hidden_layer_sizes=(100, 50), max_iter=500, \n                         learning_rate_init=0.001, early_stopping=True, random_state=42)\n    model.fit(scale(X_train), y_train)\n    return model\n\ndef getRandomForestModel(X_train, y_train):\n    model = RandomForestRegressor(n_estimators=300, random_state=42,\n                                  max_depth=10, bootstrap=True, min_samples_leaf=4,\n                                  min_samples_split=2)\n    model.fit(X_train, y_train)\n    return model\n\ndef getLinearRegressionModel(X_train, y_train):\n    x_with_const = sm.add_constant(X_train)\n    model = sm.OLS(y_train, x_with_const).fit()\n    return model\n\ndef getFeatureImportancesPca(model):\n    feature_importances = model.feature_importances_\n    sorted_idx = np.argsort(feature_importances)[::-1]\n    plt.figure(figsize=(10, 6))\n    plt.title(\"PCA Component Importances\")\n    plt.bar(range(len(feature_importances)), feature_importances[sorted_idx], align=\"center\")\n    plt.xticks(range(len(feature_importances)), [f\"PC{i}\" for i in sorted_idx], rotation=90)\n    plt.xlim([-1, len(feature_importances)])\n    plt.show()\n\ndef getFeatureImportances(model, columns):\n    feature_importances = model.feature_importances_\n    sorted_idx = np.argsort(feature_importances)[::-1]\n    plt.figure(figsize=(10, 6))\n    plt.title(\"Feature Importances\")\n    plt.bar(range(len(columns)), feature_importances[sorted_idx], align=\"center\")\n    plt.xticks(range(len(columns)), [columns[i] for i in sorted_idx], rotation=90)\n    plt.xlim([-1, len(columns)])\n    plt.show()\n\ndef league_test_split(df, test_size=0.2, random_state=42):\n    leagues = df['league_id'].unique()\n    train_leagues, test_leagues = train_test_split(leagues, test_size=test_size, random_state=random_state)\n    X_train = df[df['league_id'].isin(train_leagues)].drop(['league_rank', 'league_id'], axis=1)\n    y_train = df[df['league_id'].isin(train_leagues)]['league_rank']\n    X_test = ",
        "middle": "df[df['league_id'].isin(test_leagues)].drop(['league_rank', 'league_id'], axis=1)",
        "suffix": "    y_test = df[df['league_id'].isin(test_leagues)]['league_rank']\n    return X_train, X_test, y_train, y_test\n\ndef scale(x):\n    scaler = StandardScaler(with_mean=True, with_std=True)\n    return scaler.fit_transform(x)\n\ndef evaluate_model_performance(model_name, y_true, predictions, num_attributes, print_accuracy=False):\n    print(f\"Model: {model_name}\")\n    if not print_accuracy:\n        mae = mean_absolute_error(y_true, predictions)\n        print(f\"Mean Absolute Error (MAE): {mae}\")\n        r2 = r2_score(y_true, predictions)\n        ar2 = get_rsquared_adj(r2, len(predictions), num_attributes)\n        print(f\"Adjusted R-squared: {r2}\")\n    else:\n        accuracy = accuracy_score(y_true, predictions)\n        print(f'Accuracy: {accuracy:.4f}')\n\ndef plot_predictions_distribution(model_name, y_true, predictions):\n    plt.hist(predictions, bins=len(set(y_true)), edgecolor='black')\n    plt.xlabel('League rank')\n    plt.ylabel('Number of predictions')\n    plt.title(f'Distribution {model_name}')\n    plt.show()\n\ndef get_rsquared_adj(r_squared, n, p):\n    adjusted_r_squared = 1 - (1 - r_squared) * (n - 1) / (n - p - 1)\n    return adjusted_r_squared\n\ndef load_data(filepath):\n    df = pd.read_csv(filepath)\n    return df\n\ndef preprocess_data(df, columns_to_normalize, columns_to_drop, groupby_column='league_id'):\n    for col in columns_to_normalize:\n        normalized_col_name = f'normalized_{col}'\n        if col in df.columns:\n            normalized_values = df.groupby(groupby_column)[col].transform(lambda x: (x - x.mean()) / x.std())\n            df[normalized_col_name] = normalized_values.fillna(0)\n    columns_to_drop = [col for col in columns_to_drop if col in df.columns]\n    df = df.drop(columns=columns_to_drop)\n    return df\n",
        "prediction": "",
        "file": "utils_models.py"
    },
    {
        "id": 28,
        "prefix": "import matplotlib\nimport matplotlib.pyplot as plt\nimport plotly.express as px\nimport seaborn as sb\nimport pandas as pd\nimport numpy as np\nimport statsmodels.api as sm\nfrom sklearn.decomposition import PCA\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.ensemble import RandomForestClassifier, RandomForestRegressor\nfrom sklearn.neural_network import MLPClassifier, MLPRegressor\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.metrics import mean_absolute_error, r2_score, accuracy_score\nimport warnings\n\nwarnings.filterwarnings(\"ignore\")\n\ndef plot_correlation_for_col(df, col_name):\n    plt.figure(figsize=(12,6))\n    correlation_matrix = df.corr()\n    sorted_col_corr = correlation_matrix[col_name].sort_values(ascending=True)\n    sorted_col_corr = sorted_col_corr.drop(col_name)\n    sb.barplot(x=sorted_col_corr.index, y=sorted_col_corr.values, palette='RdBu')\n    plt.xticks(rotation=90)\n    plt.tight_layout()\n    plt.show()\n\ndef plot_explained_variance(pca_model):\n    plt.figure(figsize=(9,3))\n    explained_variance = pca_model.explained_variance_ratio_\n    cumulative_variance = explained_variance.cumsum()\n    plt.subplot(1, 2, 1)\n    plt.bar(range(1, len(explained_variance) + 1), explained_variance, alpha=0.8, align='center')\n    plt.xlabel('Glavna komponenta')\n    plt.ylabel('Objasnjena varijansa')\n    plt.subplot(1, 2, 2)\n    plt.plot(range(1, len(cumulative_variance) + 1), cumulative_variance, '--o')\n    plt.xlabel('Broj glavnih komponenti')\n    plt.ylabel('Kumulativna varijansa')\n    plt.tight_layout()\n    plt.show()\n\ndef plot_pc_loading(pca_model, pc_idx, columns, largest_n_pc=None):\n    plt.figure(figsize=(12,6))\n    pc_loadings_df = pd.DataFrame(data=pca_model.components_, columns=columns)\n    loading = pc_loadings_df.iloc[pc_idx]\n    sorted_loading_abs = loading.abs().sort_values(ascending=True)\n    largest_n_pc = 0 if largest_n_pc is None else largest_n_pc\n    sorted_loading = loading[sorted_loading_abs.index][-largest_n_pc:]\n    sb.barplot(x=sorted_loading.index, y=sorted_loading.values, palette='Reds')\n    plt.xticks(rotation=90)\n    plt.title(f'Correlation with {pc_idx}. component')\n    plt.tight_layout()\n    plt.show()\n\ndef visualize_principal_components(principal_components: np.ndarray, n_principal_components: int, \n                                   target_col: pd.Series = None, n_samples: int = None):\n    if n_samples is not None and n_samples < principal_components.shape[0]:\n        indices = np.random.choice(principal_components.shape[0], n_samples, replace=False)\n        principal_components = principal_components[indices, :]\n        if target_col is not None:\n            target_col = target_col.iloc[indices]\n    if n_principal_components == 2:\n        fig = px.scatter(x=principal_components[:, 0], y=principal_components[:, 1],\n                         opacity=0.6, color=target_col, color_continuous_scale='RdBu', width=700, height=600)\n        fig.update_traces(marker={'size': 10})\n        fig.update_layout(title='Principal components visualisations', xaxis_title=\"PC1\", yaxis_title=\"PC2\")\n        fig.show()\n    elif n_principal_components == 3:\n        fig = px.scatter_3d(x=principal_components[:, 0], y=principal_components[:, 1], z=principal_components[:, 2],\n                            opacity=0.6, color=target_col, color_continuous_scale='RdBu', width=1000)\n        fig.update_traces(marker={'size': 6})\n        fig.update_layout(title='Principal components visualisations', \n                          scene=dict(xaxis_title=\"PC1\", yaxis_title=\"PC2\", zaxis_title=\"PC3\",\n                                     xaxis_autorange='reversed', yaxis_autorange='reversed'))\n        fig.show()\n    else:\n        raise Exception('number of principal components must be 2 or 3')\n\ndef getPcaModel(df, n_components=2, random_state=42):\n    x = df.drop(columns=['league_rank', 'league_id'])\n    x_scaled = scale(x)\n    pca_model = PCA(n_components=n_components, random_state=random_state)\n    principal_components = pca_model.fit_transform(x_scaled)\n    return pca_model, principal_components\n\ndef getRandomForestClassifier(X_train, y_train):\n    model = RandomForestClassifier(n_estimators=300, random_state=42,\n                                   max_depth=10, bootstrap=True, min_samples_leaf=1,\n                                   min_samples_split=10)\n    model.fit(X_train, y_train)\n    return model\n\ndef getMLPClassifier(X_train, y_train):\n    model = MLPClassifier(hidden_layer_sizes=(50,50), activation='relu', solver='adam',\n                          max_iter=1000, learning_rate='constant', alpha=0.05,\n                          early_stopping=True, random_state=42)\n    model.fit(scale(X_train), y_train)\n    return model\n\ndef getMLPRegressorModel(X_train, y_train):\n    model = MLPRegressor(hidden_layer_sizes=(100, 50), max_iter=500, \n                         learning_rate_init=0.001, early_stopping=True, random_state=42)\n    model.fit(scale(X_train), y_train)\n    return model\n\ndef getRandomForestModel(X_train, y_train):\n    model = RandomForestRegressor(n_estimators=300, random_state=42,\n                                  max_depth=10, bootstrap=True, min_samples_leaf=4,\n                                  min_samples_split=2)\n    model.fit(X_train, y_train)\n    return model\n\ndef getLinearRegressionModel(X_train, y_train):\n    x_with_const = sm.add_constant(X_train)\n    model = sm.OLS(y_train, x_with_const).fit()\n    return model\n\ndef getFeatureImportancesPca(model):\n    feature_importances = model.feature_importances_\n    sorted_idx = np.argsort(feature_importances)[::-1]\n    plt.figure(figsize=(10, 6))\n    plt.title(\"PCA Component Importances\")\n    plt.bar(range(len(feature_importances)), feature_importances[sorted_idx], align=\"center\")\n    plt.xticks(range(len(feature_importances)), [f\"PC{i}\" for i in sorted_idx], rotation=90)\n    plt.xlim([-1, len(feature_importances)])\n    plt.show()\n\ndef getFeatureImportances(model, columns):\n    feature_importances = model.feature_importances_\n    sorted_idx = np.argsort(feature_importances)[::-1]\n    plt.figure(figsize=(10, 6))\n    plt.title(\"Feature Importances\")\n    plt.bar(range(len(columns)), feature_importances[sorted_idx], align=\"center\")\n    plt.xticks(range(len(columns)), [columns[i] for i in sorted_idx], rotation=90)\n    plt.xlim([-1, len(columns)])\n    plt.show()\n\ndef league_test_split(df, test_size=0.2, random_state=42):\n    leagues = df['league_id'].unique()\n    train_leagues, test_leagues = train_test_split(leagues, test_size=test_size, random_state=random_state)\n    X_train = df[df['league_id'].isin(train_leagues)].drop(['league_rank', 'league_id'], axis=1)\n    y_train = df[df['league_id'].isin(train_leagues)]['league_rank']\n    X_test = df[df['league_id'].isin(test_leagues)].drop(['league_rank', 'league_id'], axis=1)\n    y_test = df[df['league_id'].isin(test_leagues)]['league_rank']\n    return X_train, X_test, y_train, y_test\n\ndef scale(x):\n    scaler = StandardScaler(with_mean=True, with_std=True)\n    return scaler.fit_transform(x)\n\ndef evaluate_model_performance(model_name, y_true, predictions, num_attributes, print_accuracy=False):\n    print(f\"Model: {model_name}\")\n    if not print_accuracy:\n        mae = mean_absolute_error(y_true, predictions)\n        print(f\"Mean Absolute Error (MAE): {mae}\")\n        r2 = r2_score(y_true, predictions)\n        ar2 = get_rsquared_adj(r2, len(predictions), num_attributes)\n        print(f\"Adjusted R-squared: {r2}\")\n    else:\n        accuracy = accuracy_score(y_true, predictions)\n        print(f'Accuracy: {accuracy:.4f}')\n\ndef plot_predictions_distribution(model_name, y_true, predictions):\n    plt.hist(predictions, bins=len(set(y_true)), edgecolor='black')\n    plt.xlabel('League rank')\n    plt.ylabel('Number of predictions')\n    plt.title(f'Distribution {model_name}')\n    plt.show()\n\ndef get_rsquared_adj(r_squared, n, p):\n    adjusted_r_squared = 1 - (1 - r_squared) * (n - 1) / (n - p - 1)\n    return adjusted_r_squared\n\ndef load_data(filepath):\n    df = pd.read_csv(filepath)\n    return df\n\ndef preprocess_data(df, columns_to_normalize, columns_to_drop, groupby_column='league_id'):\n    for col in columns_to_normalize:\n    ",
        "middle": "    normalized_col_name = f'normalized_{col}'",
        "suffix": "        if col in df.columns:\n            normalized_values = df.groupby(groupby_column)[col].transform(lambda x: (x - x.mean()) / x.std())\n            df[normalized_col_name] = normalized_values.fillna(0)\n    columns_to_drop = [col for col in columns_to_drop if col in df.columns]\n    df = df.drop(columns=columns_to_drop)\n    return df\n",
        "prediction": "",
        "file": "utils_models.py"
    },
    {
        "id": 29,
        "prefix": "import matplotlib\nimport matplotlib.pyplot as plt\nimport plotly.express as px\nimport seaborn as sb\nimport pandas as pd\nimport numpy as np\nimport statsmodels.api as sm\nfrom sklearn.decomposition import PCA\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.ensemble import RandomForestClassifier, RandomForestRegressor\nfrom sklearn.neural_network import MLPClassifier, MLPRegressor\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.metrics import mean_absolute_error, r2_score, accuracy_score\nimport warnings\n\nwarnings.filterwarnings(\"ignore\")\n\ndef plot_correlation_for_col(df, col_name):\n    plt.figure(figsize=(12,6))\n    correlation_matrix = df.corr()\n    sorted_col_corr = correlation_matrix[col_name].sort_values(ascending=True)\n    sorted_col_corr = sorted_col_corr.drop(col_name)\n    sb.barplot(x=sorted_col_corr.index, y=sorted_col_corr.values, palette='RdBu')\n    plt.xticks(rotation=90)\n    plt.tight_layout()\n    plt.show()\n\ndef plot_explained_variance(pca_model):\n    plt.figure(figsize=(9,3))\n    explained_variance = pca_model.explained_variance_ratio_\n    cumulative_variance = explained_variance.cumsum()\n    plt.subplot(1, 2, 1)\n    plt.bar(range(1, len(explained_variance) + 1), explained_variance, alpha=0.8, align='center')\n    plt.xlabel('Glavna komponenta')\n    plt.ylabel('Objasnjena varijansa')\n    plt.subplot(1, 2, 2)\n    plt.plot(range(1, len(cumulative_variance) + 1), cumulative_variance, '--o')\n    plt.xlabel('Broj glavnih komponenti')\n    plt.ylabel('Kumulativna varijansa')\n    plt.tight_layout()\n    plt.show()\n\ndef plot_pc_loading(pca_model, pc_idx, columns, largest_n_pc=None):\n    plt.figure(figsize=(12,6))\n    pc_loadings_df = pd.DataFrame(data=pca_model.components_, columns=columns)\n    loading = pc_loadings_df.iloc[pc_idx]\n    sorted_loading_abs = loading.abs().sort_values(ascending=True)\n    largest_n_pc = 0 if largest_n_pc is None else largest_n_pc\n    sorted_loading = loading[sorted_loading_abs.index][-largest_n_pc:]\n    sb.barplot(x=sorted_loading.index, y=sorted_loading.values, palette='Reds')\n    plt.xticks(rotation=90)\n    plt.title(f'Correlation with {pc_idx}. component')\n    plt.tight_layout()\n    plt.show()\n\ndef visualize_principal_components(principal_components: np.ndarray, n_principal_components: int, \n                                   target_col: pd.Series = None, n_samples: int = None):\n    if n_samples is not None and n_samples < principal_components.shape[0]:\n        indices = np.random.choice(principal_components.shape[0], n_samples, replace=False)\n        principal_components = principal_components[indices, :]\n        if target_col is not None:\n            target_col = target_col.iloc[indices]\n    if n_principal_components == 2:\n        fig = px.scatter(x=principal_components[:, 0], y=principal_components[:, 1],\n                         opacity=0.6, color=target_col, color_continuous_scale='RdBu', width=700, height=600)\n        fig.update_traces(marker={'size': 10})\n        fig.update_layout(title='Principal components visualisations', xaxis_title=\"PC1\", yaxis_title=\"PC2\")\n        fig.show()\n    elif n_principal_components == 3:\n        fig = px.scatter_3d(x=principal_components[:, 0], y=principal_components[:, 1], z=principal_components[:, 2],\n                            opacity=0.6, color=target_col, color_continuous_scale='RdBu', width=1000)\n        fig.update_traces(marker={'size': 6})\n        fig.update_layout(title='Principal components visualisations', \n                          scene=dict(xaxis_title=\"PC1\", yaxis_title=\"PC2\", zaxis_title=\"PC3\",\n                                     xaxis_autorange='reversed', yaxis_autorange='reversed'))\n        fig.show()\n    else:\n        raise Exception('number of principal components must be 2 or 3')\n\ndef getPcaModel(df, n_components=2, random_state=42):\n    x = df.drop(columns=['league_rank', 'league_id'])\n    x_scaled = scale(x)\n    pca_model = PCA(n_components=n_components, random_state=random_state)\n    principal_components = pca_model.fit_transform(x_scaled)\n    return pca_model, principal_components\n\ndef getRandomForestClassifier(X_train, y_train):\n    model = RandomForestClassifier(n_estimators=300, random_state=42,\n                                   max_depth=10, bootstrap=True, min_samples_leaf=1,\n                                   min_samples_split=10)\n    model.fit(X_train, y_train)\n    return model\n\ndef getMLPClassifier(X_train, y_train):\n    model = MLPClassifier(hidden_layer_sizes=(50,50), activation='relu', solver='adam',\n                          max_iter=1000, learning_rate='constant', alpha=0.05,\n                          early_stopping=True, random_state=42)\n    model.fit(scale(X_train), y_train)\n    return model\n\ndef getMLPRegressorModel(X_train, y_train):\n    model = MLPRegressor(hidden_layer_sizes=(100, 50), max_iter=500, \n                         learning_rate_init=0.001, early_stopping=True, random_state=42)\n    model.fit(scale(X_train), y_train)\n    return model\n\ndef getRandomForestModel(X_train, y_train):\n    model = RandomForestRegressor(n_estimators=300, random_state=42,\n                                  max_depth=10, bootstrap=True, min_samples_leaf=4,\n                                  min_samples_split=2)\n    model.fit(X_train, y_train)\n    return model\n\ndef getLinearRegressionModel(X_train, y_train):\n    x_with_const = sm.add_constant(X_train)\n    model = sm.OLS(y_train, x_with_const).fit()\n    return model\n\ndef getFeatureImportancesPca(model):\n    feature_importances = model.feature_importances_\n    sorted_idx = np.argsort(feature_importances)[::-1]\n    plt.figure(figsize=(10, 6))\n    plt.title(\"PCA Component Importances\")\n    plt.bar(range(len(feature_importances)), feature_importances[sorted_idx], align=\"center\")\n    plt.xticks(range(len(feature_importances)), [f\"PC{i}\" for i in sorted_idx], rotation=90)\n    plt.xlim([-1, len(feature_importances)])\n    plt.show()\n\ndef getFeatureImportances(model, columns):\n    feature_importances = model.feature_importances_\n    sorted_idx = np.argsort(feature_importances)[::-1]\n    plt.figure(figsize=(10, 6))\n    plt.title(\"Feature Importances\")\n    plt.bar(range(len(columns)), feature_importances[sorted_idx], align=\"center\")\n    plt.xticks(range(len(columns)), [columns[i] for i in sorted_idx], rotation=90)\n    plt.xlim([-1, len(columns)])\n    plt.show()\n\ndef league_test_split(df, test_size=0.2, random_state=42):\n    leagues = df['league_id'].unique()\n    train_leagues, test_leagues = train_test_split(leagues, test_size=test_size, random_state=random_state)\n    X_train = df[df['league_id'].isin(train_leagues)].drop(['league_rank', 'league_id'], axis=1)\n    y_train = df[df['league_id'].isin(train_leagues)]['league_rank']\n    X_test = df[df['league_id'].isin(test_leagues)].drop(['league_rank', 'league_id'], axis=1)\n    y_test = df[df['league_id'].isin(test_leagues)]['league_rank']\n    return X_train, X_test, y_train, y_test\n\ndef scale(x):\n    scaler = StandardScaler(with_mean=True, with_std=True)\n    return scaler.fit_transform(x)\n\ndef evaluate_model_performance(model_name, ",
        "middle": "y_true, predictions, num_attributes, print_accuracy=False):",
        "suffix": "    print(f\"Model: {model_name}\")\n    if not print_accuracy:\n        mae = mean_absolute_error(y_true, predictions)\n        print(f\"Mean Absolute Error (MAE): {mae}\")\n        r2 = r2_score(y_true, predictions)\n        ar2 = get_rsquared_adj(r2, len(predictions), num_attributes)\n        print(f\"Adjusted R-squared: {r2}\")\n    else:\n        accuracy = accuracy_score(y_true, predictions)\n        print(f'Accuracy: {accuracy:.4f}')\n\ndef plot_predictions_distribution(model_name, y_true, predictions):\n    plt.hist(predictions, bins=len(set(y_true)), edgecolor='black')\n    plt.xlabel('League rank')\n    plt.ylabel('Number of predictions')\n    plt.title(f'Distribution {model_name}')\n    plt.show()\n\ndef get_rsquared_adj(r_squared, n, p):\n    adjusted_r_squared = 1 - (1 - r_squared) * (n - 1) / (n - p - 1)\n    return adjusted_r_squared\n\ndef load_data(filepath):\n    df = pd.read_csv(filepath)\n    return df\n\ndef preprocess_data(df, columns_to_normalize, columns_to_drop, groupby_column='league_id'):\n    for col in columns_to_normalize:\n        normalized_col_name = f'normalized_{col}'\n        if col in df.columns:\n            normalized_values = df.groupby(groupby_column)[col].transform(lambda x: (x - x.mean()) / x.std())\n            df[normalized_col_name] = normalized_values.fillna(0)\n    columns_to_drop = [col for col in columns_to_drop if col in df.columns]\n    df = df.drop(columns=columns_to_drop)\n    return df\n",
        "prediction": "",
        "file": "utils_models.py"
    },
    {
        "id": 30,
        "prefix": "import matplotlib\nimport matplotlib.pyplot as plt\nimport plotly.express as px\nimport seaborn as sb\nimport pandas as pd\nimport numpy as np\nimport statsmodels.api as sm\nfrom sklearn.decomposition import PCA\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.ensemble import RandomForestClassifier, RandomForestRegressor\nfrom sklearn.neural_network import MLPClassifier, MLPRegressor\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.metrics import mean_absolute_error, r2_score, accuracy_score\nimport warnings\n\nwarnings.filterwarnings(\"ignore\")\n\ndef plot_correlation_for_col(df, col_name):\n    plt.figure(figsize=(12,6))\n    correlation_matrix = df.corr()\n    sorted_col_corr = correlation_matrix[col_name].sort_values(ascending=True)\n    sorted_col_corr = sorted_col_corr.drop(col_name)\n    sb.barplot(x=sorted_col_corr.index, y=sorted_col_corr.values, palette='RdBu')\n    plt.xticks(rotation=90)\n    plt.tight_layout()\n    plt.show()\n\ndef plot_explained_variance(pca_model):\n    plt.figure(figsize=(9,3))\n    explained_variance = pca_model.explained_variance_ratio_\n    cumulative_variance = explained_variance.cumsum()\n    plt.subplot(1, 2, 1)\n    plt.bar(range(1, len(explained_variance) + 1), explained_variance, alpha=0.8, align='center')\n    plt.xlabel('Glavna komponenta')\n    plt.ylabel('Objasnjena varijansa')\n    plt.subplot(1, 2, 2)\n    plt.plot(range(1, len(cumulative_variance) + 1), cumulative_variance, '--o')\n    plt.xlabel('Broj glavnih komponenti')\n    plt.ylabel('Kumulativna varijansa')\n    plt.tight_layout()\n    plt.show()\n\ndef plot_pc_loading(pca_model, pc_idx, columns, largest_n_pc=None):\n    plt.figure(figsize=(12,6))\n    pc_loadings_df = pd.DataFrame(data=pca_model.components_, columns=columns)\n    loading = pc_loadings_df.iloc[pc_idx]\n    sorted_loading_abs = loading.abs().sort_values(ascending=True)\n    largest_n_pc = 0 if largest_n_pc is None else largest_n_pc\n    sorted_loading = loading[sorted_loading_abs.index][-largest_n_pc:]\n    sb.barplot(x=sorted_loading.index, y=sorted_loading.values, palette='Reds')\n    plt.xticks(rotation=90)\n    plt.title(f'Correlation with {pc_idx}. component')\n    plt.tight_layout()\n    plt.show()\n\ndef visualize_principal_components(principal_components: np.ndarray, n_principal_components: int, \n                                   target_col: pd.Series = None, n_samples: int = None):\n    if n_samples is not None and n_samples < principal_components.shape[0]:\n        indices = np.random.choice(principal_components.shape[0], n_samples, replace=False)\n        principal_components = principal_components[indices, :]\n        if target_col is not None:\n            target_col = target_col.iloc[indices]\n    if n_principal_components == 2:\n        fig = px.scatter(x=principal_components[:, 0], y=principal_components[:, 1],\n                         opacity=0.6, color=target_col, color_continuous_scale='RdBu', width=700, height=600)\n        fig.update_traces(marker={'size': 10})\n        fig.update_layout(title='Principal components visualisations', xaxis_title=\"PC1\", yaxis_title=\"PC2\")\n        fig.show()\n    elif n_principal_components == 3:\n        fig = px.scatter_3d(x=principal_components[:, 0], y=principal_components[:, 1], z=principal_components[:, 2],\n                            opacity=0.6, color=target_col, color_continuous_scale='RdBu', width=1000)\n        fig.update_traces(marker={'size': 6})\n        fig.update_layout(title='Principal components visualisations', \n                          scene=dict(xaxis_title=\"PC1\", yaxis_title=\"PC2\", zaxis_title=\"PC3\",\n                                     xaxis_autorange='reversed', yaxis_autorange='reversed'))\n        fig.show()\n    else:\n        raise Exception('number of principal components must be 2 or 3')\n\ndef getPcaModel(df, n_components=2, random_state=42):\n    x = df.drop(columns=['league_rank', 'league_id'])\n    x_scaled = scale(x)\n",
        "middle": "    pca_model = PCA(n_components=n_components, random_state=random_state)",
        "suffix": "    principal_components = pca_model.fit_transform(x_scaled)\n    return pca_model, principal_components\n\ndef getRandomForestClassifier(X_train, y_train):\n    model = RandomForestClassifier(n_estimators=300, random_state=42,\n                                   max_depth=10, bootstrap=True, min_samples_leaf=1,\n                                   min_samples_split=10)\n    model.fit(X_train, y_train)\n    return model\n\ndef getMLPClassifier(X_train, y_train):\n    model = MLPClassifier(hidden_layer_sizes=(50,50), activation='relu', solver='adam',\n                          max_iter=1000, learning_rate='constant', alpha=0.05,\n                          early_stopping=True, random_state=42)\n    model.fit(scale(X_train), y_train)\n    return model\n\ndef getMLPRegressorModel(X_train, y_train):\n    model = MLPRegressor(hidden_layer_sizes=(100, 50), max_iter=500, \n                         learning_rate_init=0.001, early_stopping=True, random_state=42)\n    model.fit(scale(X_train), y_train)\n    return model\n\ndef getRandomForestModel(X_train, y_train):\n    model = RandomForestRegressor(n_estimators=300, random_state=42,\n                                  max_depth=10, bootstrap=True, min_samples_leaf=4,\n                                  min_samples_split=2)\n    model.fit(X_train, y_train)\n    return model\n\ndef getLinearRegressionModel(X_train, y_train):\n    x_with_const = sm.add_constant(X_train)\n    model = sm.OLS(y_train, x_with_const).fit()\n    return model\n\ndef getFeatureImportancesPca(model):\n    feature_importances = model.feature_importances_\n    sorted_idx = np.argsort(feature_importances)[::-1]\n    plt.figure(figsize=(10, 6))\n    plt.title(\"PCA Component Importances\")\n    plt.bar(range(len(feature_importances)), feature_importances[sorted_idx], align=\"center\")\n    plt.xticks(range(len(feature_importances)), [f\"PC{i}\" for i in sorted_idx], rotation=90)\n    plt.xlim([-1, len(feature_importances)])\n    plt.show()\n\ndef getFeatureImportances(model, columns):\n    feature_importances = model.feature_importances_\n    sorted_idx = np.argsort(feature_importances)[::-1]\n    plt.figure(figsize=(10, 6))\n    plt.title(\"Feature Importances\")\n    plt.bar(range(len(columns)), feature_importances[sorted_idx], align=\"center\")\n    plt.xticks(range(len(columns)), [columns[i] for i in sorted_idx], rotation=90)\n    plt.xlim([-1, len(columns)])\n    plt.show()\n\ndef league_test_split(df, test_size=0.2, random_state=42):\n    leagues = df['league_id'].unique()\n    train_leagues, test_leagues = train_test_split(leagues, test_size=test_size, random_state=random_state)\n    X_train = df[df['league_id'].isin(train_leagues)].drop(['league_rank', 'league_id'], axis=1)\n    y_train = df[df['league_id'].isin(train_leagues)]['league_rank']\n    X_test = df[df['league_id'].isin(test_leagues)].drop(['league_rank', 'league_id'], axis=1)\n    y_test = df[df['league_id'].isin(test_leagues)]['league_rank']\n    return X_train, X_test, y_train, y_test\n\ndef scale(x):\n    scaler = StandardScaler(with_mean=True, with_std=True)\n    return scaler.fit_transform(x)\n\ndef evaluate_model_performance(model_name, y_true, predictions, num_attributes, print_accuracy=False):\n    print(f\"Model: {model_name}\")\n    if not print_accuracy:\n        mae = mean_absolute_error(y_true, predictions)\n        print(f\"Mean Absolute Error (MAE): {mae}\")\n        r2 = r2_score(y_true, predictions)\n        ar2 = get_rsquared_adj(r2, len(predictions), num_attributes)\n        print(f\"Adjusted R-squared: {r2}\")\n    else:\n        accuracy = accuracy_score(y_true, predictions)\n        print(f'Accuracy: {accuracy:.4f}')\n\ndef plot_predictions_distribution(model_name, y_true, predictions):\n    plt.hist(predictions, bins=len(set(y_true)), edgecolor='black')\n    plt.xlabel('League rank')\n    plt.ylabel('Number of predictions')\n    plt.title(f'Distribution {model_name}')\n    plt.show()\n\ndef get_rsquared_adj(r_squared, n, p):\n    adjusted_r_squared = 1 - (1 - r_squared) * (n - 1) / (n - p - 1)\n    return adjusted_r_squared\n\ndef load_data(filepath):\n    df = pd.read_csv(filepath)\n    return df\n\ndef preprocess_data(df, columns_to_normalize, columns_to_drop, groupby_column='league_id'):\n    for col in columns_to_normalize:\n        normalized_col_name = f'normalized_{col}'\n        if col in df.columns:\n            normalized_values = df.groupby(groupby_column)[col].transform(lambda x: (x - x.mean()) / x.std())\n            df[normalized_col_name] = normalized_values.fillna(0)\n    columns_to_drop = [col for col in columns_to_drop if col in df.columns]\n    df = df.drop(columns=columns_to_drop)\n    return df\n",
        "prediction": "",
        "file": "utils_models.py"
    }
]